{
  "version": 3,
  "sources": ["../../src/instantiateFaustModuleFromFile.ts", "../../src/FaustAudioWorkletProcessor.ts", "../../src/FaustFFTAudioWorkletProcessor.ts", "../../node_modules/tslib/tslib.es6.mjs", "../../node_modules/@aws-crypto/sha256-js/src/constants.ts", "../../node_modules/@aws-crypto/sha256-js/src/RawSha256.ts", "../../node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js", "../../node_modules/@aws-crypto/util/src/convertToBuffer.ts", "../../node_modules/@aws-crypto/util/src/isEmptyData.ts", "../../node_modules/@aws-crypto/sha256-js/src/jsSha256.ts", "../../src/FaustCompiler.ts", "../../src/FaustDspInstance.ts", "../../src/FaustWasmInstantiator.ts", "../../src/FaustSensors.ts", "../../src/FaustWebAudioDsp.ts", "../../src/FaustOfflineProcessor.ts", "../../src/FaustSvgDiagrams.ts", "../../src/FaustCmajor.ts", "../../src/LibFaust.ts", "../../src/WavEncoder.ts", "../../src/WavDecoder.ts", "../../src/SoundfileReader.ts", "../../src/FaustAudioWorkletCommunicator.ts", "../../src/FaustAudioWorkletNode.ts", "../../src/FaustScriptProcessorNode.ts", "../../src/FaustDspGenerator.ts"],
  "sourcesContent": ["import type { FaustModuleFactory } from './types';\n\n/**\n * Load libfaust-wasm files, than instantiate libFaust\n * @param jsFile path to `libfaust-wasm.js`\n * @param dataFile path to `libfaust-wasm.data`\n * @param wasmFile path to `libfaust-wasm.wasm`\n */\nconst instantiateFaustModuleFromFile = async (\n    jsFile: string,\n    dataFile = jsFile.replace(/c?js$/, 'data'),\n    wasmFile = jsFile.replace(/c?js$/, 'wasm')\n) => {\n    let FaustModule: FaustModuleFactory;\n    let dataBinary: ArrayBuffer;\n    let wasmBinary: ArrayBuffer;\n    const jsCodeHead = /var (.+) = \\(/;\n    if (typeof window === 'object') {\n        let jsCode = await (await fetch(jsFile)).text();\n        jsCode = `${jsCode}\nexport default ${jsCode.match(jsCodeHead)?.[1]};\n`;\n        const jsFileMod = URL.createObjectURL(\n            new Blob([jsCode], { type: 'text/javascript' })\n        );\n        FaustModule = (await import(/* webpackIgnore: true */ jsFileMod))\n            .default;\n        dataBinary = await (await fetch(dataFile)).arrayBuffer();\n        wasmBinary = await (await fetch(wasmFile)).arrayBuffer();\n    } else {\n        const { promises: fs } = await import('fs');\n        const { pathToFileURL } = await import('url');\n        let jsCode = await fs.readFile(jsFile, { encoding: 'utf-8' });\n        jsCode = `\nimport process from \"process\";\nimport * as path from \"path\";\nimport { createRequire } from \"module\";\nimport { fileURLToPath } from \"url\";\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\nconst __filename = fileURLToPath(import.meta.url);\nconst require = createRequire(import.meta.url);\n\n${jsCode}\n\nexport default ${jsCode.match(jsCodeHead)?.[1]};\n`;\n        const jsFileMod = jsFile.replace(/c?js$/, 'mjs');\n        await fs.writeFile(jsFileMod, jsCode);\n        FaustModule = (\n            await import(\n                /* webpackIgnore: true */ pathToFileURL(jsFileMod).href\n            )\n        ).default;\n        await fs.unlink(jsFileMod);\n        // Using a type assertion `as ArrayBuffer` to satisfy the strict type checking.\n        dataBinary = new Uint8Array(await fs.readFile(dataFile))\n            .buffer as ArrayBuffer;\n        wasmBinary = new Uint8Array(await fs.readFile(wasmFile))\n            .buffer as ArrayBuffer;\n    }\n    const faustModule = await FaustModule({\n        wasmBinary,\n        getPreloadedPackage: (\n            remotePackageName: string,\n            remotePackageSize: number\n        ) => {\n            if (remotePackageName === 'libfaust-wasm.data') return dataBinary;\n            return new ArrayBuffer(0);\n        }\n    });\n    return faustModule;\n};\n\nexport default instantiateFaustModuleFromFile;\n", "import type { FaustAudioWorkletProcessorCommunicator } from './FaustAudioWorkletCommunicator';\nimport type FaustWasmInstantiator from './FaustWasmInstantiator';\nimport type {\n    FaustBaseWebAudioDsp,\n    FaustWebAudioDspVoice,\n    FaustMonoWebAudioDsp,\n    FaustPolyWebAudioDsp\n} from './FaustWebAudioDsp';\nimport type {\n    AudioParamDescriptor,\n    AudioWorkletGlobalScope,\n    LooseFaustDspFactory,\n    FaustDspMeta,\n    FaustUIItem\n} from './types';\nimport type {\n    AudioWorkletGlobalScope as WamAudioWorkletGlobalScope,\n    WamParamMgrSDKBaseModuleScope\n} from '@webaudiomodules/sdk-parammgr';\n\n/**\n * Injected in the string to be compiled on AudioWorkletProcessor side\n */\nexport interface FaustData {\n    processorName: string;\n    dspName: string;\n    dspMeta: FaustDspMeta;\n    poly: boolean;\n    effectMeta?: FaustDspMeta;\n}\nexport interface FaustAudioWorkletProcessorDependencies<\n    Poly extends boolean = false\n> {\n    FaustBaseWebAudioDsp: typeof FaustBaseWebAudioDsp;\n    FaustMonoWebAudioDsp: Poly extends true\n        ? undefined\n        : typeof FaustMonoWebAudioDsp;\n    FaustPolyWebAudioDsp: Poly extends true\n        ? typeof FaustPolyWebAudioDsp\n        : undefined;\n    FaustWebAudioDspVoice: Poly extends true\n        ? typeof FaustWebAudioDspVoice\n        : undefined;\n    FaustWasmInstantiator: typeof FaustWasmInstantiator;\n    FaustAudioWorkletProcessorCommunicator: typeof FaustAudioWorkletProcessorCommunicator;\n}\nexport interface FaustAudioWorkletNodeOptions<Poly extends boolean = false>\n    extends AudioWorkletNodeOptions {\n    processorOptions: Poly extends true\n        ? FaustPolyAudioWorkletProcessorOptions\n        : FaustMonoAudioWorkletProcessorOptions;\n}\nexport interface FaustMonoAudioWorkletNodeOptions\n    extends AudioWorkletNodeOptions {\n    processorOptions: FaustMonoAudioWorkletProcessorOptions;\n}\nexport interface FaustPolyAudioWorkletNodeOptions\n    extends AudioWorkletNodeOptions {\n    processorOptions: FaustPolyAudioWorkletProcessorOptions;\n}\nexport interface FaustAudioWorkletProcessorOptions {\n    name: string;\n    sampleSize: number;\n    // for WAMs\n    moduleId?: string;\n    instanceId?: string;\n}\nexport interface FaustMonoAudioWorkletProcessorOptions\n    extends FaustAudioWorkletProcessorOptions {\n    factory: LooseFaustDspFactory;\n}\nexport interface FaustPolyAudioWorkletProcessorOptions\n    extends FaustAudioWorkletProcessorOptions {\n    voiceFactory: LooseFaustDspFactory;\n    mixerModule: WebAssembly.Module;\n    voices: number;\n    effectFactory?: LooseFaustDspFactory;\n}\n\n// Dynamic AudioWorkletProcessor code generator\nconst getFaustAudioWorkletProcessor = <Poly extends boolean = false>(\n    dependencies: FaustAudioWorkletProcessorDependencies<Poly>,\n    faustData: FaustData,\n    register = true\n): typeof AudioWorkletProcessor => {\n    const { registerProcessor, AudioWorkletProcessor, sampleRate } =\n        globalThis as unknown as AudioWorkletGlobalScope;\n\n    const {\n        FaustBaseWebAudioDsp,\n        FaustWasmInstantiator,\n        FaustAudioWorkletProcessorCommunicator\n    } = dependencies;\n\n    const { processorName, dspName, dspMeta, effectMeta, poly } = faustData;\n\n    // Analyse voice JSON to generate AudioParam parameters\n    const analysePolyParameters = (\n        item: FaustUIItem\n    ): AudioParamDescriptor | null => {\n        const polyKeywords = [\n            '/gate',\n            '/freq',\n            '/gain',\n            '/key',\n            '/vel',\n            '/velocity'\n        ];\n        const isPolyReserved =\n            'address' in item &&\n            !!polyKeywords.find((k) => item.address.endsWith(k));\n        if (poly && isPolyReserved) return null;\n        if (\n            item.type === 'vslider' ||\n            item.type === 'hslider' ||\n            item.type === 'nentry'\n        ) {\n            return {\n                name: item.address,\n                defaultValue: item.init || 0,\n                minValue: item.min || 0,\n                maxValue: item.max || 0\n            };\n        } else if (item.type === 'button' || item.type === 'checkbox') {\n            return {\n                name: item.address,\n                defaultValue: item.init || 0,\n                minValue: 0,\n                maxValue: 1\n            };\n        }\n        return null;\n    };\n\n    /**\n     * Base class for Monophonic and Polyphonic AudioWorkletProcessor\n     */\n    abstract class FaustAudioWorkletProcessor<\n        Poly extends boolean = false\n    > extends AudioWorkletProcessor {\n        // Use ! syntax when the field is not defined in the constructor\n        protected fDSPCode!: Poly extends true\n            ? FaustPolyWebAudioDsp\n            : FaustMonoWebAudioDsp;\n\n        protected paramValuesCache: Record<string, number> = {};\n\n        protected wamInfo?: { moduleId: string; instanceId: string };\n        protected fCommunicator: FaustAudioWorkletProcessorCommunicator;\n\n        constructor(options: FaustAudioWorkletNodeOptions<Poly>) {\n            super(options);\n\n            // Setup port message handling\n            this.fCommunicator = new FaustAudioWorkletProcessorCommunicator(\n                this.port\n            );\n\n            const { parameterDescriptors } = this\n                .constructor as typeof AudioWorkletProcessor;\n            parameterDescriptors.forEach((pd) => {\n                this.paramValuesCache[pd.name] = pd.defaultValue || 0;\n            });\n\n            const { moduleId, instanceId } = options.processorOptions;\n            if (!moduleId || !instanceId) return;\n            this.wamInfo = { moduleId, instanceId };\n        }\n\n        static get parameterDescriptors() {\n            const params = [] as AudioParamDescriptor[];\n            // Analyse voice JSON to generate AudioParam parameters\n            const callback = (item: FaustUIItem) => {\n                const param = analysePolyParameters(item);\n                if (param) params.push(param);\n            };\n            FaustBaseWebAudioDsp.parseUI(dspMeta.ui, callback);\n            // Analyse effect JSON to generate AudioParam parameters\n            if (effectMeta)\n                FaustBaseWebAudioDsp.parseUI(effectMeta.ui, callback);\n            return params;\n        }\n\n        setupWamEventHandler() {\n            if (!this.wamInfo) return;\n            const { moduleId, instanceId } = this.wamInfo;\n            const { webAudioModules } =\n                globalThis as unknown as WamAudioWorkletGlobalScope;\n            const ModuleScope = webAudioModules.getModuleScope(\n                moduleId\n            ) as WamParamMgrSDKBaseModuleScope;\n            const paramMgrProcessor =\n                ModuleScope?.paramMgrProcessors?.[instanceId];\n            if (!paramMgrProcessor) return;\n            if (paramMgrProcessor.handleEvent) return;\n            paramMgrProcessor.handleEvent = (event) => {\n                if (event.type === 'wam-midi')\n                    this.midiMessage(event.data.bytes);\n            };\n        }\n\n        process(\n            inputs: Float32Array[][],\n            outputs: Float32Array[][],\n            parameters: { [key: string]: Float32Array }\n        ) {\n            // Update controls (possibly needed for sample accurate control)\n            for (const path in parameters) {\n                const [paramValue] = parameters[path];\n                if (paramValue !== this.paramValuesCache[path]) {\n                    // Set value and update the cache\n                    this.setParamValue(path, paramValue);\n                }\n            }\n            if (this.fCommunicator.getNewAccDataAvailable()) {\n                const acc = this.fCommunicator.getAcc();\n                if (acc) {\n                    this.fCommunicator.setNewAccDataAvailable(false);\n                    const { invert, ...data } = acc;\n                    this.propagateAcc(data, invert);\n                }\n            }\n            if (this.fCommunicator.getNewGyrDataAvailable()) {\n                const gyr = this.fCommunicator.getGyr();\n                if (gyr) {\n                    this.fCommunicator.setNewGyrDataAvailable(false);\n                    this.propagateGyr(gyr);\n                }\n            }\n\n            return this.fDSPCode.compute(inputs[0], outputs[0]);\n        }\n\n        protected handleMessageAux(e: MessageEvent) {\n            // use arrow function for binding\n            const msg = e.data;\n\n            switch (msg.type) {\n                // Generic MIDI message\n                case 'midi': {\n                    this.midiMessage(msg.data);\n                    break;\n                }\n                // Typed MIDI message\n                case 'ctrlChange': {\n                    this.ctrlChange(msg.data[0], msg.data[1], msg.data[2]);\n                    break;\n                }\n                case 'pitchWheel': {\n                    this.pitchWheel(msg.data[0], msg.data[1]);\n                    break;\n                }\n                case 'keyOn': {\n                    this.keyOn(msg.data[0], msg.data[1], msg.data[2]);\n                    break;\n                }\n                case 'keyOff': {\n                    this.keyOff(msg.data[0], msg.data[1], msg.data[2]);\n                    break;\n                }\n                // Generic data message\n                case 'param': {\n                    this.setParamValue(msg.data.path, msg.data.value);\n                    break;\n                }\n                // Plot handler set on demand\n                case 'setPlotHandler': {\n                    if (msg.data) {\n                        this.fDSPCode.setPlotHandler((output, index, events) =>\n                            this.port.postMessage({\n                                type: 'plot',\n                                value: output,\n                                index,\n                                events\n                            })\n                        );\n                    } else {\n                        this.fDSPCode.setPlotHandler(null);\n                    }\n                    break;\n                }\n                case 'setupWamEventHandler': {\n                    this.setupWamEventHandler();\n                    break;\n                }\n                case 'start': {\n                    this.fDSPCode.start();\n                    break;\n                }\n                case 'stop': {\n                    this.fDSPCode.stop();\n                    break;\n                }\n                case 'destroy': {\n                    this.port.close();\n                    this.fDSPCode.destroy();\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n\n        protected setParamValue(path: string, value: number) {\n            this.fDSPCode.setParamValue(path, value);\n            this.paramValuesCache[path] = value;\n        }\n\n        protected midiMessage(data: number[] | Uint8Array) {\n            this.fDSPCode.midiMessage(data);\n        }\n\n        protected ctrlChange(channel: number, ctrl: number, value: number) {\n            this.fDSPCode.ctrlChange(channel, ctrl, value);\n        }\n\n        protected pitchWheel(channel: number, wheel: number) {\n            this.fDSPCode.pitchWheel(channel, wheel);\n        }\n\n        protected keyOn(channel: number, pitch: number, velocity: number) {\n            this.fDSPCode.keyOn(channel, pitch, velocity);\n        }\n\n        protected keyOff(channel: number, pitch: number, velocity: number) {\n            this.fDSPCode.keyOff(channel, pitch, velocity);\n        }\n\n        protected propagateAcc(\n            accelerationIncludingGravity: NonNullable<\n                DeviceMotionEvent['accelerationIncludingGravity']\n            >,\n            invert: boolean = false\n        ) {\n            this.fDSPCode.propagateAcc(accelerationIncludingGravity, invert);\n        }\n\n        protected propagateGyr(\n            event: Pick<DeviceOrientationEvent, 'alpha' | 'beta' | 'gamma'>\n        ) {\n            this.fDSPCode.propagateGyr(event);\n        }\n    }\n\n    /**\n     * Monophonic AudioWorkletProcessor\n     */\n    class FaustMonoAudioWorkletProcessor extends FaustAudioWorkletProcessor<false> {\n        constructor(options: FaustAudioWorkletNodeOptions) {\n            super(options);\n            const { FaustMonoWebAudioDsp } =\n                dependencies as FaustAudioWorkletProcessorDependencies<false>;\n            const { factory, sampleSize } = options.processorOptions;\n\n            const instance =\n                FaustWasmInstantiator.createSyncMonoDSPInstance(factory);\n\n            // Create Monophonic DSP\n            this.fDSPCode = new FaustMonoWebAudioDsp(\n                instance,\n                sampleRate,\n                sampleSize,\n                128,\n                factory.soundfiles\n            );\n\n            // Setup port message handling\n            this.port.addEventListener('message', this.handleMessageAux);\n            this.port.start();\n\n            // Setup output handler\n            this.fDSPCode.setOutputParamHandler((path, value) =>\n                this.port.postMessage({ path, value, type: 'out-param' })\n            );\n            this.fDSPCode.setInputParamHandler((path, value) =>\n                this.port.postMessage({ path, value, type: 'in-param' })\n            );\n\n            this.fDSPCode.start();\n        }\n\n        protected handleMessageAux = (e: MessageEvent) => {\n            // use arrow function for binding\n            super.handleMessageAux(e);\n        };\n    }\n\n    /**\n     * Polyphonic AudioWorkletProcessor\n     */\n    class FaustPolyAudioWorkletProcessor extends FaustAudioWorkletProcessor<true> {\n        constructor(options: FaustPolyAudioWorkletNodeOptions) {\n            super(options);\n            const { FaustPolyWebAudioDsp } =\n                dependencies as FaustAudioWorkletProcessorDependencies<true>;\n\n            const {\n                voiceFactory,\n                mixerModule,\n                voices,\n                effectFactory,\n                sampleSize\n            } = options.processorOptions;\n\n            const instance = FaustWasmInstantiator.createSyncPolyDSPInstance(\n                voiceFactory,\n                mixerModule,\n                voices,\n                effectFactory\n            );\n\n            const soundfiles = {\n                ...effectFactory?.soundfiles,\n                ...voiceFactory.soundfiles\n            };\n            // Create Polyphonic DSP\n            this.fDSPCode = new FaustPolyWebAudioDsp(\n                instance,\n                sampleRate,\n                sampleSize,\n                128,\n                soundfiles\n            );\n\n            // Setup port message handling\n            this.port.addEventListener('message', this.handleMessageAux);\n            this.port.start();\n\n            // Setup output handler\n            this.fDSPCode.setOutputParamHandler((path, value) =>\n                this.port.postMessage({ path, value, type: 'out-param' })\n            );\n            this.fDSPCode.setInputParamHandler((path, value) =>\n                this.port.postMessage({ path, value, type: 'in-param' })\n            );\n\n            this.fDSPCode.start();\n        }\n\n        protected midiMessage(data: number[] | Uint8Array) {\n            const cmd = data[0] >> 4;\n            const channel = data[0] & 0xf;\n            const data1 = data[1];\n            const data2 = data[2];\n            if (cmd === 8 || (cmd === 9 && data2 === 0))\n                this.keyOff(channel, data1, data2);\n            else if (cmd === 9) this.keyOn(channel, data1, data2);\n            else super.midiMessage(data);\n        }\n\n        protected handleMessageAux = (e: MessageEvent) => {\n            // use arrow function for binding\n            const msg = e.data;\n            switch (msg.type) {\n                case 'keyOn':\n                    this.keyOn(msg.data[0], msg.data[1], msg.data[2]);\n                    break;\n                case 'keyOff':\n                    this.keyOff(msg.data[0], msg.data[1], msg.data[2]);\n                    break;\n                default:\n                    super.handleMessageAux(e);\n                    break;\n            }\n        };\n\n        // Public API\n        keyOn(channel: number, pitch: number, velocity: number) {\n            this.fDSPCode.keyOn(channel, pitch, velocity);\n        }\n\n        keyOff(channel: number, pitch: number, velocity: number) {\n            this.fDSPCode.keyOff(channel, pitch, velocity);\n        }\n\n        allNotesOff(hard: boolean) {\n            this.fDSPCode.allNotesOff(hard);\n        }\n    }\n\n    const Processor = poly\n        ? FaustPolyAudioWorkletProcessor\n        : FaustMonoAudioWorkletProcessor;\n    if (register) {\n        try {\n            registerProcessor(\n                processorName || dspName || (poly ? 'mydsp_poly' : 'mydsp'),\n                Processor\n            );\n        } catch (error) {\n            console.warn(error);\n        }\n    }\n\n    return poly\n        ? FaustPolyAudioWorkletProcessor\n        : FaustMonoAudioWorkletProcessor;\n};\n\nexport default getFaustAudioWorkletProcessor;\n", "import type { FaustAudioWorkletProcessorCommunicator } from './FaustAudioWorkletCommunicator';\nimport type { FaustMonoDspInstance } from './FaustDspInstance';\nimport type FaustWasmInstantiator from './FaustWasmInstantiator';\nimport type {\n    FaustBaseWebAudioDsp,\n    FaustMonoWebAudioDsp,\n    PlotHandler\n} from './FaustWebAudioDsp';\nimport type {\n    AudioParamDescriptor,\n    AudioWorkletGlobalScope,\n    LooseFaustDspFactory,\n    FaustDspMeta,\n    FaustUIItem,\n    InterfaceFFT,\n    TWindowFunction,\n    Writeable,\n    TypedArray,\n    FFTUtils\n} from './types';\nimport type {\n    AudioWorkletGlobalScope as WamAudioWorkletGlobalScope,\n    WamParamMgrSDKBaseModuleScope\n} from '@webaudiomodules/sdk-parammgr';\n\nexport interface FaustFFTOptionsData {\n    fftSize: number;\n    fftOverlap: number;\n    noIFFT: boolean;\n    /** Index number of the default window function, leave undefined or -1 for rectangular (no windowing) */\n    defaultWindowFunction: number;\n}\n\n/**\n * Injected in the string to be compiled on AudioWorkletProcessor side\n */\nexport interface FaustFFTData {\n    processorName: string;\n    dspName: string;\n    dspMeta: FaustDspMeta;\n    fftOptions?: Partial<FaustFFTOptionsData>;\n}\nexport interface FaustFFTAudioWorkletProcessorDependencies {\n    FaustBaseWebAudioDsp: typeof FaustBaseWebAudioDsp;\n    FaustMonoWebAudioDsp: typeof FaustMonoWebAudioDsp;\n    FaustWasmInstantiator: typeof FaustWasmInstantiator;\n    FaustAudioWorkletProcessorCommunicator: typeof FaustAudioWorkletProcessorCommunicator;\n    FFTUtils: typeof FFTUtils;\n}\nexport interface FaustFFTAudioWorkletNodeOptions\n    extends AudioWorkletNodeOptions {\n    processorOptions: FaustFFTAudioWorkletProcessorOptions;\n}\nexport interface FaustFFTAudioWorkletProcessorOptions {\n    name: string;\n    sampleSize: number;\n    factory: LooseFaustDspFactory;\n    // for WAMs\n    moduleId?: string;\n    instanceId?: string;\n}\n\n// Dynamic AudioWorkletProcessor code generator\nconst getFaustFFTAudioWorkletProcessor = (\n    dependencies: FaustFFTAudioWorkletProcessorDependencies,\n    faustData: FaustFFTData,\n    register = true\n): typeof AudioWorkletProcessor => {\n    const { registerProcessor, AudioWorkletProcessor, sampleRate } =\n        globalThis as unknown as AudioWorkletGlobalScope;\n\n    const {\n        FaustBaseWebAudioDsp,\n        FaustWasmInstantiator,\n        FaustMonoWebAudioDsp,\n        FaustAudioWorkletProcessorCommunicator,\n        FFTUtils\n    } = dependencies;\n\n    const { processorName, dspName, dspMeta, fftOptions } = faustData;\n\n    const { windowFunctions, getFFT, fftToSignal, signalToFFT, signalToNoFFT } =\n        FFTUtils;\n\n    /**\n     * Ceil a number to multiple of another\n     */\n    const ceil = (x: number, to: number): number =>\n        Math.abs(to) < 1\n            ? Math.ceil(x * (1 / to)) / (1 / to)\n            : Math.ceil(x / to) * to;\n\n    /**\n     * Mod support wrapping with negative numbers\n     */\n    const mod = (x: number, y: number): number => ((x % y) + y) % y;\n\n    const apply = (\n        array: Writeable<ArrayLike<number>>,\n        windowFunction: TWindowFunction\n    ) => {\n        for (let i = 0; i < array.length; i++) {\n            array[i] *= windowFunction(i, array.length);\n        }\n    };\n\n    const fftParamKeywords = [\n        '/fftSize',\n        '/fftHopSize',\n        '/fftOverlap',\n        '/windowFunction',\n        '/noIFFT'\n    ];\n\n    /**\n     * Copy buffer to another, support negative offset index\n     */\n    const setTypedArray = <T extends TypedArray = TypedArray>(\n        to: T,\n        from: T,\n        offsetTo = 0,\n        offsetFrom = 0\n    ) => {\n        const toLength = to.length;\n        const fromLength = from.length;\n        const spillLength = Math.min(toLength, fromLength);\n        let spilled = 0;\n        let $to = mod(offsetTo, toLength) || 0;\n        let $from = mod(offsetFrom, fromLength) || 0;\n        while (spilled < spillLength) {\n            const $spillLength = Math.min(\n                spillLength - spilled,\n                toLength - $to,\n                fromLength - $from\n            );\n            const $fromEnd = $from + $spillLength;\n            if ($from === 0 && $fromEnd === fromLength) to.set(from, $to);\n            else to.set(from.subarray($from, $fromEnd), $to);\n            $to = ($to + $spillLength) % toLength;\n            $from = $fromEnd % fromLength;\n            spilled += $spillLength;\n        }\n        return $to;\n    };\n\n    // Analyse JSON to generate AudioParam parameters\n    const analyseParameters = (\n        item: FaustUIItem\n    ): AudioParamDescriptor | null => {\n        const isFFTReserved =\n            'address' in item &&\n            !!fftParamKeywords.find((k) => item.address.endsWith(k));\n        if (isFFTReserved) return null;\n        if (\n            item.type === 'vslider' ||\n            item.type === 'hslider' ||\n            item.type === 'nentry'\n        ) {\n            return {\n                name: item.address,\n                defaultValue: item.init || 0,\n                minValue: item.min || 0,\n                maxValue: item.max || 0\n            };\n        } else if (item.type === 'button' || item.type === 'checkbox') {\n            return {\n                name: item.address,\n                defaultValue: item.init || 0,\n                minValue: 0,\n                maxValue: 1\n            };\n        }\n        return null;\n    };\n    /**\n     * Class for Faust FFT AudioWorkletProcessor\n     */\n    class FaustFFTAudioWorkletProcessor extends AudioWorkletProcessor {\n        protected fDSPCode: FaustMonoWebAudioDsp;\n\n        protected paramValuesCache: Record<string, number> = {};\n\n        protected wamInfo?: { moduleId: string; instanceId: string };\n        protected communicator: FaustAudioWorkletProcessorCommunicator;\n\n        private dspInstance!: FaustMonoDspInstance;\n        private sampleSize!: number;\n\n        private destroyed = false;\n        /** Pointer of next start sample to write of the FFT input window */\n        private $inputWrite = 0;\n        /** Pointer of next start sample to read of the FFT input window */\n        private $inputRead = 0;\n        /** Pointer of next start sample to write of the FFT output window */\n        private $outputWrite = 0;\n        /** Pointer of next start sample to read of the FFT output window */\n        private $outputRead = 0;\n        /** Not perform in IFFT when reconstruct the audio signal */\n        private noIFFT = false;\n        /** audio data from input, array of channels */\n        private readonly fftInput: Float32Array[] = [];\n        /** audio data for output, array of channels */\n        private readonly fftOutput: Float32Array[] = [];\n        /** Generated from the current window function */\n        private window: Float32Array;\n        /** Generated from the current window's rolling sum square */\n        private windowSumSquare: Float32Array;\n\n        /** FFT constructor */\n        private FFT: typeof InterfaceFFT;\n        /** Real FFT interface */\n        private rfft: InterfaceFFT;\n        /** Faust param name of fftHopSize */\n        private fftHopSizeParam: string | undefined;\n        /** FFT Overlaps, 1 means no overlap */\n        private fftOverlap = 0;\n        private fftHopSize = 0;\n        private fftSize = 0;\n        private fftBufferSize = 0;\n        private fftProcessorZeros: Float32Array;\n        private noIFFTBuffer: Float32Array;\n\n        private fPlotHandler: PlotHandler | null = null;\n        private fCachedEvents: { type: string; data: any }[] = [];\n        private fBufferNum = 0;\n        private soundfiles: LooseFaustDspFactory['soundfiles'] = {};\n        get fftProcessorBufferSize() {\n            return this.fftSize / 2 + 1;\n        }\n        private windowFunction: TWindowFunction | null = null;\n\n        constructor(options: FaustFFTAudioWorkletNodeOptions) {\n            super(options);\n\n            // Setup port message handling\n            this.port.addEventListener('message', this.handleMessageAux);\n            this.port.start();\n            this.communicator = new FaustAudioWorkletProcessorCommunicator(\n                this.port\n            );\n\n            const { parameterDescriptors } = this\n                .constructor as typeof AudioWorkletProcessor;\n            parameterDescriptors.forEach((pd) => {\n                this.paramValuesCache[pd.name] = pd.defaultValue || 0;\n            });\n\n            const { factory, sampleSize } = options.processorOptions;\n\n            this.dspInstance =\n                FaustWasmInstantiator.createSyncMonoDSPInstance(factory);\n            this.sampleSize = sampleSize;\n            this.soundfiles = factory.soundfiles;\n\n            // Init the FFT constructor and the Faust FFT Processor\n            this.initFFT();\n\n            const { moduleId, instanceId } = options.processorOptions;\n            if (!moduleId || !instanceId) return;\n            this.wamInfo = { moduleId, instanceId };\n        }\n\n        async initFFT(): Promise<true> {\n            // Use injected function to instantiate the FFT constructor\n            this.FFT = await getFFT();\n            // Init Faust FFT Processor\n            await this.createFFTProcessor();\n            return true;\n        }\n\n        static get parameterDescriptors() {\n            const params = [] as AudioParamDescriptor[];\n            // Analyse voice JSON to generate AudioParam parameters\n            const callback = (item: FaustUIItem) => {\n                const param = analyseParameters(item);\n                if (param) params.push(param);\n            };\n            FaustBaseWebAudioDsp.parseUI(dspMeta.ui, callback);\n            // Add to Faust parameters, FFT specified parameters\n            return [\n                ...params,\n                {\n                    defaultValue: fftOptions?.fftSize || 1024,\n                    maxValue: 2 ** 32,\n                    minValue: 2,\n                    name: 'fftSize'\n                },\n                {\n                    defaultValue: fftOptions?.fftOverlap || 2,\n                    maxValue: 32,\n                    minValue: 1,\n                    name: 'fftOverlap'\n                },\n                {\n                    defaultValue:\n                        typeof fftOptions?.defaultWindowFunction === 'number'\n                            ? fftOptions.defaultWindowFunction + 1\n                            : 0,\n                    maxValue: windowFunctions?.length || 0,\n                    minValue: 0,\n                    name: 'windowFunction'\n                },\n                {\n                    defaultValue: +!!fftOptions?.noIFFT || 0,\n                    maxValue: 1,\n                    minValue: 0,\n                    name: 'noIFFT'\n                }\n            ];\n        }\n\n        setupWamEventHandler() {\n            if (!this.wamInfo) return;\n            const { moduleId, instanceId } = this.wamInfo;\n            const { webAudioModules } =\n                globalThis as unknown as WamAudioWorkletGlobalScope;\n            const ModuleScope = webAudioModules.getModuleScope(\n                moduleId\n            ) as WamParamMgrSDKBaseModuleScope;\n            const paramMgrProcessor =\n                ModuleScope?.paramMgrProcessors?.[instanceId];\n            if (!paramMgrProcessor) return;\n            if (paramMgrProcessor.handleEvent) return;\n            paramMgrProcessor.handleEvent = (event) => {\n                if (event.type === 'wam-midi')\n                    this.midiMessage(event.data.bytes);\n            };\n        }\n\n        processFFT() {\n            // Get the number of samples that need to proceed, from the input r/w pointers\n            let samplesForFFT =\n                mod(this.$inputWrite - this.$inputRead, this.fftBufferSize) ||\n                this.fftBufferSize;\n            // Start process, until no more enough samples\n            while (samplesForFFT >= this.fftSize) {\n                let fftProcessorOutputs: Float32Array[] = [];\n                // Faust processing, use a callback to avoid extra data copy\n                this.fDSPCode.compute(\n                    (inputs) => {\n                        // for each audio input channel, three Faust FFT input buffers can be generated (real, imag, FFT bin index)\n                        for (\n                            let i = 0;\n                            i <\n                            Math.min(\n                                this.fftInput.length,\n                                Math.ceil(inputs.length / 3)\n                            );\n                            i++\n                        ) {\n                            // FFT forward, use a callback to avoid extra data copy\n                            const ffted = this.rfft.forward((fftBuffer) => {\n                                setTypedArray(\n                                    fftBuffer,\n                                    this.fftInput[i],\n                                    0,\n                                    this.$inputRead\n                                );\n                                // Windowing the input\n                                for (let j = 0; j < fftBuffer.length; j++) {\n                                    fftBuffer[j] *= this.window[j];\n                                }\n                                // data for FFT (fftBuffer) is prepared\n                            });\n                            // write FFTed spectral data to three Faust FFT input buffers (real, imag, FFT bin index)\n                            fftToSignal(\n                                ffted,\n                                inputs[i * 3],\n                                inputs[i * 3 + 1],\n                                inputs[i * 3 + 2]\n                            );\n                            // Faust inputs are prepared\n                        }\n                        // If the Faust DSP has more inputs, fill them (zeros or real/imag, fill FFT bin indexes)\n                        for (\n                            let i = this.fftInput.length * 3;\n                            i < inputs.length;\n                            i++\n                        ) {\n                            if (i % 3 === 2)\n                                inputs[i].forEach((v, j) => (inputs[i][j] = j));\n                            else inputs[i].fill(0);\n                        }\n                    },\n                    (outputs) => {\n                        // Get the Faust DSP outputs\n                        fftProcessorOutputs = outputs as Float32Array[];\n                    }\n                );\n\n                // Advance FFT input read pointers\n                this.$inputRead += this.fftHopSize;\n                this.$inputRead %= this.fftBufferSize;\n\n                samplesForFFT -= this.fftHopSize;\n\n                // Do inverse FFT on the processed data by Faust DSP, and write the reconstructed signal to the output buffer\n                for (let i = 0; i < this.fftOutput.length; i++) {\n                    let iffted: Float32Array;\n                    // If noIFFT option in enabled, then no need to do inverse IFFT, use the injected function to convert\n                    if (this.noIFFT) {\n                        iffted = this.noIFFTBuffer;\n                        signalToNoFFT(\n                            fftProcessorOutputs[i * 2] ||\n                                this.fftProcessorZeros,\n                            fftProcessorOutputs[i * 2 + 1] ||\n                                this.fftProcessorZeros,\n                            iffted\n                        );\n                    } else {\n                        // FFT inverse, use a callback to avoid extra data copy\n                        iffted = this.rfft.inverse((ifftBuffer) => {\n                            // Convert the Faust DSP output (real/imag plans) to an array for inverse FFT\n                            signalToFFT(\n                                fftProcessorOutputs[i * 2] ||\n                                    this.fftProcessorZeros,\n                                fftProcessorOutputs[i * 2 + 1] ||\n                                    this.fftProcessorZeros,\n                                ifftBuffer\n                            );\n                            // ifftBuffer is prepared\n                        });\n                    }\n                    // Windowing the output\n                    for (let j = 0; j < iffted.length; j++) {\n                        iffted[j] *= this.window[j];\n                    }\n                    // Overlap-add, preparing the windowSumSquare array for reverse the windowing effect when output the audio\n                    let $: number;\n                    // First part, add the part that is overlaped with the previous window\n                    for (let j = 0; j < iffted.length - this.fftHopSize; j++) {\n                        $ = mod(this.$outputWrite + j, this.fftBufferSize);\n                        this.fftOutput[i][$] += iffted[j];\n                        if (i === 0)\n                            this.windowSumSquare[$] += this.noIFFT\n                                ? this.window[j]\n                                : this.window[j] ** 2;\n                    }\n                    // Second part, write directly to the output buffer\n                    for (\n                        let j = iffted.length - this.fftHopSize;\n                        j < iffted.length;\n                        j++\n                    ) {\n                        $ = mod(this.$outputWrite + j, this.fftBufferSize);\n                        this.fftOutput[i][$] = iffted[j];\n                        if (i === 0)\n                            this.windowSumSquare[$] = this.noIFFT\n                                ? this.window[j]\n                                : this.window[j] ** 2;\n                    }\n                }\n                // Advance FFT output write pointers\n                this.$outputWrite += this.fftHopSize;\n                this.$outputWrite %= this.fftBufferSize;\n            }\n        }\n\n        process(\n            inputs: Float32Array[][],\n            outputs: Float32Array[][],\n            parameters: { [key: string]: Float32Array }\n        ) {\n            if (this.destroyed) return false;\n            if (!this.FFT) return true;\n            const input = inputs[0];\n            const output = outputs[0];\n            const inputChannels = input?.length || 0;\n            const outputChannels = output?.length || 0;\n            // if (input.length === 0) return true;\n\n            const bufferSize = input?.length\n                ? Math.max(...input.map((c) => c.length)) || 128\n                : 128;\n\n            // Reset FFT and related buffers if necessary (checks in the resetFFT method)\n            this.noIFFT = !!parameters.noIFFT[0];\n            this.resetFFT(\n                ~~parameters.fftSize[0],\n                ~~parameters.fftOverlap[0],\n                ~~parameters.windowFunction[0],\n                inputChannels,\n                outputChannels,\n                bufferSize\n            );\n\n            if (!this.fDSPCode) return true;\n\n            for (const path in parameters) {\n                if (fftParamKeywords.find((k) => `/${path}`.endsWith(k)))\n                    continue;\n                const [paramValue] = parameters[path];\n                if (paramValue !== this.paramValuesCache[path]) {\n                    // Set value and update the cache\n                    this.setParamValue(path, paramValue);\n                }\n            }\n            if (this.communicator.getNewAccDataAvailable()) {\n                const acc = this.communicator.getAcc();\n                if (acc) {\n                    this.communicator.setNewAccDataAvailable(false);\n                    const { invert, ...data } = acc;\n                    this.propagateAcc(data, invert);\n                }\n            }\n            if (this.communicator.getNewGyrDataAvailable()) {\n                const gyr = this.communicator.getGyr();\n                if (gyr) {\n                    this.communicator.setNewGyrDataAvailable(false);\n                    this.propagateGyr(gyr);\n                }\n            }\n\n            // Write audio input into fftInput buffer, advance pointers\n            if (input?.length) {\n                let $inputWrite = 0;\n                for (let i = 0; i < input.length; i++) {\n                    const inputWindow = this.fftInput[i];\n                    const channel = input[i].length\n                        ? input[i]\n                        : new Float32Array(bufferSize);\n                    $inputWrite = setTypedArray(\n                        inputWindow,\n                        channel,\n                        this.$inputWrite\n                    );\n                }\n                this.$inputWrite = $inputWrite;\n            } else {\n                this.$inputWrite += bufferSize;\n                this.$inputWrite %= this.fftBufferSize;\n            }\n\n            // Do FFT if necessary\n            this.processFFT();\n\n            // Read from fftOutput buffer for audio output, applying windowSumSquare to reverse the doubled windowing effect\n            for (let i = 0; i < output.length; i++) {\n                setTypedArray(\n                    output[i],\n                    this.fftOutput[i],\n                    0,\n                    this.$outputRead\n                );\n                // let a = 0;\n                let div = 0;\n                for (let j = 0; j < bufferSize; j++) {\n                    div =\n                        this.windowSumSquare[\n                            mod(this.$outputRead + j, this.fftBufferSize)\n                        ];\n                    output[i][j] /= div < 1e-8 ? 1 : div;\n                }\n            }\n            // Advance pointers\n            this.$outputRead += bufferSize;\n            this.$outputRead %= this.fftBufferSize;\n\n            // plot\n            if (this.fPlotHandler) {\n                this.port.postMessage({\n                    type: 'plot',\n                    value: output,\n                    index: this.fBufferNum++,\n                    events: this.fCachedEvents\n                });\n                this.fCachedEvents = [];\n            }\n            return true;\n        }\n\n        protected handleMessageAux = (e: MessageEvent) => {\n            // use arrow function for binding\n            const msg = e.data;\n\n            switch (msg.type) {\n                // Generic MIDI message\n                case 'midi':\n                    this.midiMessage(msg.data);\n                    break;\n                // Typed MIDI message\n                case 'ctrlChange':\n                    this.ctrlChange(msg.data[0], msg.data[1], msg.data[2]);\n                    break;\n                case 'pitchWheel':\n                    this.pitchWheel(msg.data[0], msg.data[1]);\n                    break;\n                // Generic data message\n                case 'param':\n                    this.setParamValue(msg.data.path, msg.data.value);\n                    break;\n                // Plot handler set on demand\n                case 'setPlotHandler': {\n                    if (msg.data) {\n                        this.fPlotHandler = (output, index, events) => {\n                            if (events) this.fCachedEvents.push(...events);\n                        };\n                    } else {\n                        this.fPlotHandler = null;\n                    }\n                    this.fDSPCode?.setPlotHandler(this.fPlotHandler);\n                    break;\n                }\n                case 'setupWamEventHandler': {\n                    this.setupWamEventHandler();\n                    break;\n                }\n                case 'start': {\n                    this.fDSPCode?.start();\n                    break;\n                }\n                case 'stop': {\n                    this.fDSPCode?.stop();\n                    break;\n                }\n                case 'destroy': {\n                    this.port.close();\n                    this.destroy();\n                    break;\n                }\n                default:\n                    break;\n            }\n        };\n\n        protected setParamValue(path: string, value: number) {\n            this.fDSPCode?.setParamValue(path, value);\n            this.paramValuesCache[path] = value;\n        }\n\n        protected midiMessage(data: number[] | Uint8Array) {\n            this.fDSPCode?.midiMessage(data);\n        }\n\n        protected ctrlChange(channel: number, ctrl: number, value: number) {\n            this.fDSPCode?.ctrlChange(channel, ctrl, value);\n        }\n\n        protected pitchWheel(channel: number, wheel: number) {\n            this.fDSPCode?.pitchWheel(channel, wheel);\n        }\n\n        protected propagateAcc(\n            accelerationIncludingGravity: NonNullable<\n                DeviceMotionEvent['accelerationIncludingGravity']\n            >,\n            invert: boolean = false\n        ) {\n            this.fDSPCode.propagateAcc(accelerationIncludingGravity, invert);\n        }\n\n        protected propagateGyr(\n            event: Pick<DeviceOrientationEvent, 'alpha' | 'beta' | 'gamma'>\n        ) {\n            this.fDSPCode.propagateGyr(event);\n        }\n\n        resetFFT(\n            sizeIn: number,\n            overlapIn: number,\n            windowFunctionIn: number,\n            inputChannels: number,\n            outputChannels: number,\n            bufferSize: number\n        ) {\n            const fftSize = ~~ceil(Math.max(2, sizeIn || 1024), 2);\n            const fftOverlap = ~~Math.min(fftSize, Math.max(1, overlapIn));\n            const fftHopSize = ~~Math.max(1, fftSize / fftOverlap);\n            const latency = fftSize - Math.min(fftHopSize, bufferSize);\n            let windowFunction: TWindowFunction | null = null;\n\n            // set the window function from the injected list\n            if (windowFunctionIn !== 0) {\n                windowFunction =\n                    typeof windowFunctions === 'object'\n                        ? windowFunctions[~~windowFunctionIn - 1] || null\n                        : null;\n            }\n            const fftSizeChanged = fftSize !== this.fftSize;\n\n            const fftOverlapChanged = fftOverlap !== this.fftOverlap;\n            // Reset FFT vars if the size is changed\n            if (fftSizeChanged || fftOverlapChanged) {\n                this.fftSize = fftSize;\n                this.fftOverlap = fftOverlap;\n                this.fftHopSize = fftHopSize;\n                this.$inputWrite = 0;\n                this.$inputRead = 0;\n                this.$outputWrite = 0;\n                this.$outputRead = -latency;\n                this.fftBufferSize = Math.max(\n                    fftSize * 2 - this.fftHopSize,\n                    bufferSize * 2\n                );\n                if (!fftSizeChanged && this.fftHopSizeParam)\n                    this.fDSPCode?.setParamValue(\n                        this.fftHopSizeParam,\n                        this.fftHopSize\n                    );\n            }\n\n            // Reset the FFT interface and the Faust Processor\n            if (fftSizeChanged) {\n                this.rfft?.dispose();\n                this.rfft = new this.FFT(fftSize);\n                this.noIFFTBuffer = new Float32Array(this.fftSize);\n                this.createFFTProcessor();\n            }\n\n            // Calculate a window from the window function, prepare the windowSumSquare buffer\n            if (\n                fftSizeChanged ||\n                fftOverlapChanged ||\n                windowFunction !== this.windowFunction\n            ) {\n                this.windowFunction = windowFunction;\n                this.window = new Float32Array(fftSize);\n                this.window.fill(1);\n                if (windowFunction) apply(this.window, windowFunction);\n                this.windowSumSquare = new Float32Array(this.fftBufferSize);\n            }\n\n            // Reset FFT I/O buffers if necessary\n            if (this.fftInput.length > inputChannels) {\n                this.fftInput.splice(inputChannels);\n            }\n            if (this.fftOutput.length > outputChannels) {\n                this.fftOutput.splice(outputChannels);\n            }\n            if (fftSizeChanged || fftOverlapChanged) {\n                for (let i = 0; i < inputChannels; i++) {\n                    this.fftInput[i] = new Float32Array(this.fftBufferSize);\n                }\n                for (let i = 0; i < outputChannels; i++) {\n                    this.fftOutput[i] = new Float32Array(this.fftBufferSize);\n                }\n            } else {\n                if (this.fftInput.length < inputChannels) {\n                    for (let i = this.fftInput.length; i < inputChannels; i++) {\n                        this.fftInput[i] = new Float32Array(this.fftBufferSize);\n                    }\n                }\n                if (this.fftOutput.length < outputChannels) {\n                    for (\n                        let i = this.fftOutput.length;\n                        i < outputChannels;\n                        i++\n                    ) {\n                        this.fftOutput[i] = new Float32Array(\n                            this.fftBufferSize\n                        );\n                    }\n                }\n            }\n        }\n        async createFFTProcessor() {\n            this.fDSPCode?.stop();\n            this.fDSPCode?.destroy();\n\n            // Create Monophonic DSP\n            this.fDSPCode = new FaustMonoWebAudioDsp(\n                this.dspInstance,\n                sampleRate,\n                this.sampleSize,\n                this.fftProcessorBufferSize,\n                this.soundfiles\n            );\n\n            // Setup output handler\n            this.fDSPCode.setOutputParamHandler((path, value) =>\n                this.port.postMessage({ path, value, type: 'out-param' })\n            );\n            this.fDSPCode.setInputParamHandler((path, value) =>\n                this.port.postMessage({ path, value, type: 'in-param' })\n            );\n            this.fDSPCode.setPlotHandler(this.fPlotHandler);\n            const params = this.fDSPCode.getParams();\n            this.fDSPCode.start();\n            // Write the cached parameters\n            for (const path in this.paramValuesCache) {\n                if (fftParamKeywords.find((k) => `/${path}`.endsWith(k)))\n                    continue;\n                this.fDSPCode.setParamValue(path, this.paramValuesCache[path]);\n            }\n            // Write the FFT reverved parameters\n            const fftSizeParam = params.find((s) => s.endsWith('/fftSize'));\n            if (fftSizeParam)\n                this.fDSPCode.setParamValue(fftSizeParam, this.fftSize);\n            this.fftHopSizeParam = params.find((s) =>\n                s.endsWith('/fftHopSize')\n            );\n            if (this.fftHopSizeParam)\n                this.fDSPCode.setParamValue(\n                    this.fftHopSizeParam,\n                    this.fftHopSize\n                );\n            // Prepare a array of zeros for furthur usage\n            this.fftProcessorZeros = new Float32Array(\n                this.fftProcessorBufferSize\n            );\n        }\n        destroy() {\n            this.fDSPCode?.stop();\n            this.fDSPCode?.destroy();\n            this.rfft?.dispose();\n            this.destroyed = true;\n        }\n    }\n\n    const Processor = FaustFFTAudioWorkletProcessor;\n    if (register) {\n        try {\n            registerProcessor(\n                processorName || dspName || 'myfftdsp',\n                Processor\n            );\n        } catch (error) {\n            console.warn(error);\n        }\n    }\n\n    return FaustFFTAudioWorkletProcessor;\n};\n\nexport default getFaustFFTAudioWorkletProcessor;\n", "/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n", "/**\n * @internal\n */\nexport const BLOCK_SIZE: number = 64;\n\n/**\n * @internal\n */\nexport const DIGEST_LENGTH: number = 32;\n\n/**\n * @internal\n */\nexport const KEY = new Uint32Array([\n  0x428a2f98,\n  0x71374491,\n  0xb5c0fbcf,\n  0xe9b5dba5,\n  0x3956c25b,\n  0x59f111f1,\n  0x923f82a4,\n  0xab1c5ed5,\n  0xd807aa98,\n  0x12835b01,\n  0x243185be,\n  0x550c7dc3,\n  0x72be5d74,\n  0x80deb1fe,\n  0x9bdc06a7,\n  0xc19bf174,\n  0xe49b69c1,\n  0xefbe4786,\n  0x0fc19dc6,\n  0x240ca1cc,\n  0x2de92c6f,\n  0x4a7484aa,\n  0x5cb0a9dc,\n  0x76f988da,\n  0x983e5152,\n  0xa831c66d,\n  0xb00327c8,\n  0xbf597fc7,\n  0xc6e00bf3,\n  0xd5a79147,\n  0x06ca6351,\n  0x14292967,\n  0x27b70a85,\n  0x2e1b2138,\n  0x4d2c6dfc,\n  0x53380d13,\n  0x650a7354,\n  0x766a0abb,\n  0x81c2c92e,\n  0x92722c85,\n  0xa2bfe8a1,\n  0xa81a664b,\n  0xc24b8b70,\n  0xc76c51a3,\n  0xd192e819,\n  0xd6990624,\n  0xf40e3585,\n  0x106aa070,\n  0x19a4c116,\n  0x1e376c08,\n  0x2748774c,\n  0x34b0bcb5,\n  0x391c0cb3,\n  0x4ed8aa4a,\n  0x5b9cca4f,\n  0x682e6ff3,\n  0x748f82ee,\n  0x78a5636f,\n  0x84c87814,\n  0x8cc70208,\n  0x90befffa,\n  0xa4506ceb,\n  0xbef9a3f7,\n  0xc67178f2\n]);\n\n/**\n * @internal\n */\nexport const INIT = [\n  0x6a09e667,\n  0xbb67ae85,\n  0x3c6ef372,\n  0xa54ff53a,\n  0x510e527f,\n  0x9b05688c,\n  0x1f83d9ab,\n  0x5be0cd19\n];\n\n/**\n * @internal\n */\nexport const MAX_HASHABLE_LENGTH = 2 ** 53 - 1;\n", "import {\n  BLOCK_SIZE,\n  DIGEST_LENGTH,\n  INIT,\n  KEY,\n  MAX_HASHABLE_LENGTH\n} from \"./constants\";\n\n/**\n * @internal\n */\nexport class RawSha256 {\n  private state: Int32Array = Int32Array.from(INIT);\n  private temp: Int32Array = new Int32Array(64);\n  private buffer: Uint8Array = new Uint8Array(64);\n  private bufferLength: number = 0;\n  private bytesHashed: number = 0;\n\n  /**\n   * @internal\n   */\n  finished: boolean = false;\n\n  update(data: Uint8Array): void {\n    if (this.finished) {\n      throw new Error(\"Attempted to update an already finished hash.\");\n    }\n\n    let position = 0;\n    let { byteLength } = data;\n    this.bytesHashed += byteLength;\n\n    if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {\n      throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    while (byteLength > 0) {\n      this.buffer[this.bufferLength++] = data[position++];\n      byteLength--;\n\n      if (this.bufferLength === BLOCK_SIZE) {\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n    }\n  }\n\n  digest(): Uint8Array {\n    if (!this.finished) {\n      const bitsHashed = this.bytesHashed * 8;\n      const bufferView = new DataView(\n        this.buffer.buffer,\n        this.buffer.byteOffset,\n        this.buffer.byteLength\n      );\n\n      const undecoratedLength = this.bufferLength;\n      bufferView.setUint8(this.bufferLength++, 0x80);\n\n      // Ensure the final block has enough room for the hashed length\n      if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {\n        for (let i = this.bufferLength; i < BLOCK_SIZE; i++) {\n          bufferView.setUint8(i, 0);\n        }\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n\n      for (let i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {\n        bufferView.setUint8(i, 0);\n      }\n      bufferView.setUint32(\n        BLOCK_SIZE - 8,\n        Math.floor(bitsHashed / 0x100000000),\n        true\n      );\n      bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);\n\n      this.hashBuffer();\n\n      this.finished = true;\n    }\n\n    // The value in state is little-endian rather than big-endian, so flip\n    // each word into a new Uint8Array\n    const out = new Uint8Array(DIGEST_LENGTH);\n    for (let i = 0; i < 8; i++) {\n      out[i * 4] = (this.state[i] >>> 24) & 0xff;\n      out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n      out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n      out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n    }\n\n    return out;\n  }\n\n  private hashBuffer(): void {\n    const { buffer, state } = this;\n\n    let state0 = state[0],\n      state1 = state[1],\n      state2 = state[2],\n      state3 = state[3],\n      state4 = state[4],\n      state5 = state[5],\n      state6 = state[6],\n      state7 = state[7];\n\n    for (let i = 0; i < BLOCK_SIZE; i++) {\n      if (i < 16) {\n        this.temp[i] =\n          ((buffer[i * 4] & 0xff) << 24) |\n          ((buffer[i * 4 + 1] & 0xff) << 16) |\n          ((buffer[i * 4 + 2] & 0xff) << 8) |\n          (buffer[i * 4 + 3] & 0xff);\n      } else {\n        let u = this.temp[i - 2];\n        const t1 =\n          ((u >>> 17) | (u << 15)) ^ ((u >>> 19) | (u << 13)) ^ (u >>> 10);\n\n        u = this.temp[i - 15];\n        const t2 =\n          ((u >>> 7) | (u << 25)) ^ ((u >>> 18) | (u << 14)) ^ (u >>> 3);\n\n        this.temp[i] =\n          ((t1 + this.temp[i - 7]) | 0) + ((t2 + this.temp[i - 16]) | 0);\n      }\n\n      const t1 =\n        ((((((state4 >>> 6) | (state4 << 26)) ^\n          ((state4 >>> 11) | (state4 << 21)) ^\n          ((state4 >>> 25) | (state4 << 7))) +\n          ((state4 & state5) ^ (~state4 & state6))) |\n          0) +\n          ((state7 + ((KEY[i] + this.temp[i]) | 0)) | 0)) |\n        0;\n\n      const t2 =\n        ((((state0 >>> 2) | (state0 << 30)) ^\n          ((state0 >>> 13) | (state0 << 19)) ^\n          ((state0 >>> 22) | (state0 << 10))) +\n          ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) |\n        0;\n\n      state7 = state6;\n      state6 = state5;\n      state5 = state4;\n      state4 = (state3 + t1) | 0;\n      state3 = state2;\n      state2 = state1;\n      state1 = state0;\n      state0 = (t1 + t2) | 0;\n    }\n\n    state[0] += state0;\n    state[1] += state1;\n    state[2] += state2;\n    state[3] += state3;\n    state[4] += state4;\n    state[5] += state5;\n    state[6] += state6;\n    state[7] += state7;\n  }\n}\n", "export const fromUtf8 = (input) => new TextEncoder().encode(input);\n", "// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SourceData } from \"@aws-sdk/types\";\nimport { fromUtf8 as fromUtf8Browser } from \"@smithy/util-utf8\";\n\n// Quick polyfill\nconst fromUtf8 =\n  typeof Buffer !== \"undefined\" && Buffer.from\n    ? (input: string) => Buffer.from(input, \"utf8\")\n    : fromUtf8Browser;\n\nexport function convertToBuffer(data: SourceData): Uint8Array {\n  // Already a Uint8, do nothing\n  if (data instanceof Uint8Array) return data;\n\n  if (typeof data === \"string\") {\n    return fromUtf8(data);\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return new Uint8Array(\n      data.buffer,\n      data.byteOffset,\n      data.byteLength / Uint8Array.BYTES_PER_ELEMENT\n    );\n  }\n\n  return new Uint8Array(data);\n}\n", "// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SourceData } from \"@aws-sdk/types\";\n\nexport function isEmptyData(data: SourceData): boolean {\n  if (typeof data === \"string\") {\n    return data.length === 0;\n  }\n\n  return data.byteLength === 0;\n}\n", "import { BLOCK_SIZE } from \"./constants\";\nimport { RawSha256 } from \"./RawSha256\";\nimport { Checksum, SourceData } from \"@aws-sdk/types\";\nimport { isEmptyData, convertToBuffer } from \"@aws-crypto/util\";\n\nexport class Sha256 implements Checksum {\n  private readonly secret?: SourceData;\n  private hash: RawSha256;\n  private outer?: RawSha256;\n  private error: any;\n\n  constructor(secret?: SourceData) {\n    this.secret = secret;\n    this.hash = new RawSha256();\n    this.reset();\n  }\n\n  update(toHash: SourceData): void {\n    if (isEmptyData(toHash) || this.error) {\n      return;\n    }\n\n    try {\n      this.hash.update(convertToBuffer(toHash));\n    } catch (e) {\n      this.error = e;\n    }\n  }\n\n  /* This synchronous method keeps compatibility\n   * with the v2 aws-sdk.\n   */\n  digestSync(): Uint8Array {\n    if (this.error) {\n      throw this.error;\n    }\n\n    if (this.outer) {\n      if (!this.outer.finished) {\n        this.outer.update(this.hash.digest());\n      }\n\n      return this.outer.digest();\n    }\n\n    return this.hash.digest();\n  }\n\n  /* The underlying digest method here is synchronous.\n   * To keep the same interface with the other hash functions\n   * the default is to expose this as an async method.\n   * However, it can sometimes be useful to have a sync method.\n   */\n  async digest(): Promise<Uint8Array> {\n    return this.digestSync();\n  }\n\n  reset(): void {\n    this.hash = new RawSha256();\n    if (this.secret) {\n      this.outer = new RawSha256();\n      const inner = bufferFromSecret(this.secret);\n      const outer = new Uint8Array(BLOCK_SIZE);\n      outer.set(inner);\n\n      for (let i = 0; i < BLOCK_SIZE; i++) {\n        inner[i] ^= 0x36;\n        outer[i] ^= 0x5c;\n      }\n\n      this.hash.update(inner);\n      this.outer.update(outer);\n\n      // overwrite the copied key in memory\n      for (let i = 0; i < inner.byteLength; i++) {\n        inner[i] = 0;\n      }\n    }\n  }\n}\n\nfunction bufferFromSecret(secret: SourceData): Uint8Array {\n  let input = convertToBuffer(secret);\n\n  if (input.byteLength > BLOCK_SIZE) {\n    const bufferHash = new RawSha256();\n    bufferHash.update(input);\n    input = bufferHash.digest();\n  }\n\n  const buffer = new Uint8Array(BLOCK_SIZE);\n  buffer.set(input);\n  return buffer;\n}\n", "import { Sha256 } from '@aws-crypto/sha256-js';\nimport type { ILibFaust } from './LibFaust';\nimport type { FaustDspFactory, IntVector } from './types';\n\nexport const ab2str = (buf: Uint8Array) =>\n    String.fromCharCode.apply(null, Array.from(buf));\n\nexport const str2ab = (str: string) => {\n    const buf = new ArrayBuffer(str.length);\n    const bufView = new Uint8Array(buf);\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return bufView;\n};\nconst sha256 = async (str: string) => {\n    const sha256 = new Sha256();\n    sha256.update(str);\n    const hashArray = Array.from(await sha256.digest());\n    const hashHex = hashArray\n        .map((b) => b.toString(16).padStart(2, '0'))\n        .join('');\n    return hashHex;\n};\n\nexport interface IFaustCompiler {\n    /**\n     * Gives the Faust compiler version.\n     * @return a version string\n     */\n    version(): string;\n\n    /**\n     * Gives the last compilation error.\n     * @return an error string\n     */\n    getErrorMessage(): string;\n\n    /**\n     * Create a wasm factory from Faust code i.e. wasm compiled code, to be used to create monophonic instances.\n     * This function is running asynchronously.\n     *\n     * @param name - an arbitrary name for the Faust factory\n     * @param code - Faust dsp code\n     * @param args - the compiler options\n     * @returns returns the wasm factory\n     */\n    createMonoDSPFactory(\n        name: string,\n        code: string,\n        args: string\n    ): Promise<FaustDspFactory | null>;\n\n    /**\n     * Create a wasm factory from Faust code i.e. wasm compiled code, to be used to create polyphonic instances.\n     * This function is running asynchronously.\n     *\n     * @param name - an arbitrary name for the Faust factory\n     * @param code - Faust dsp code\n     * @param args - the compiler options\n     * @returns returns the wasm factory\n     */\n    createPolyDSPFactory(\n        name: string,\n        code: string,\n        args: string\n    ): Promise<FaustDspFactory | null>;\n\n    /**\n     * Delete a dsp factory.\n     *\n     * @param factory - the factory to be deleted\n     */\n    deleteDSPFactory(factory: FaustDspFactory): void;\n\n    /**\n     * Expand Faust code i.e. linearize included libraries.\n     *\n     * @param code - Faust dsp code\n     * @param args - the compiler options\n     * @returns returns the expanded dsp code\n     */\n    expandDSP(code: string, args: string): string | null;\n\n    /**\n     * Generates auxiliary files from Faust code. The output depends on the compiler options.\n     *\n     * @param name - an arbitrary name for the Faust module\n     * @param code - Faust dsp code\n     * @param args - the compiler options\n     * @returns whether the generation actually succeded\n     */\n    generateAuxFiles(name: string, code: string, args: string): boolean;\n\n    /**\n     * Delete all factories.\n     */\n    deleteAllDSPFactories(): void;\n\n    fs(): typeof FS;\n\n    getAsyncInternalMixerModule(\n        isDouble?: boolean\n    ): Promise<{ mixerBuffer: Uint8Array; mixerModule: WebAssembly.Module }>;\n    getSyncInternalMixerModule(isDouble?: boolean): {\n        mixerBuffer: Uint8Array;\n        mixerModule: WebAssembly.Module;\n    };\n}\n\nclass FaustCompiler implements IFaustCompiler {\n    private fLibFaust: ILibFaust;\n    private fErrorMessage: string;\n    private static gFactories: Map<string, FaustDspFactory> = new Map<\n        string,\n        FaustDspFactory\n    >();\n    private mixer32Buffer!: Uint8Array;\n    private mixer64Buffer!: Uint8Array;\n    private mixer32Module!: WebAssembly.Module;\n    private mixer64Module!: WebAssembly.Module;\n\n    /**\n     * Get a stringified DSP factories table\n     */\n    static serializeDSPFactories() {\n        const table: Record<\n            string,\n            { code: string; json: any; poly: boolean }\n        > = {};\n        this.gFactories.forEach((factory, shaKey) => {\n            const { code, json, poly } = factory;\n            table[shaKey] = {\n                code: btoa(ab2str(code)),\n                json: JSON.parse(json),\n                poly\n            };\n        });\n        return table;\n    }\n    /**\n     * Get a stringified DSP factories table as string\n     */\n    static stringifyDSPFactories() {\n        return JSON.stringify(this.serializeDSPFactories());\n    }\n    /**\n     * Import a DSP factories table\n     */\n    static deserializeDSPFactories(\n        table: Record<string, { code: string; json: any; poly: boolean }>\n    ) {\n        const awaited: Promise<Map<string, FaustDspFactory>>[] = [];\n        for (const shaKey in table) {\n            const factory = table[shaKey];\n            const { code, json, poly } = factory;\n            const ab = str2ab(atob(code));\n            awaited.push(\n                WebAssembly.compile(ab).then((module) =>\n                    this.gFactories.set(shaKey, {\n                        shaKey,\n                        cfactory: 0,\n                        code: ab,\n                        module,\n                        json: JSON.stringify(json),\n                        poly,\n                        soundfiles: {}\n                    })\n                )\n            );\n        }\n        return Promise.all(awaited);\n    }\n    /**\n     * Import a stringified DSP factories table\n     */\n    static importDSPFactories(tableStr: string) {\n        const table: Record<\n            string,\n            { code: string; json: any; poly: boolean }\n        > = JSON.parse(tableStr);\n        return this.deserializeDSPFactories(table);\n    }\n    constructor(libFaust: ILibFaust) {\n        this.fLibFaust = libFaust;\n        this.fErrorMessage = '';\n    }\n    private intVec2intArray(vec: IntVector) {\n        const size = vec.size();\n        const ui8Code = new Uint8Array(size);\n        for (let i = 0; i < size; i++) {\n            ui8Code[i] = vec.get(i);\n        }\n        return ui8Code;\n    }\n    private async createDSPFactory(\n        name: string,\n        code: string,\n        args: string,\n        poly: boolean\n    ) {\n        // Cleanup the cache\n        if (FaustCompiler.gFactories.size > 10) {\n            FaustCompiler.gFactories.clear();\n        }\n\n        // If code is already compiled, return the cached factory\n        const shaKey = await sha256(\n            name + code + args + (poly ? 'poly' : 'mono')\n        );\n        if (FaustCompiler.gFactories.has(shaKey)) {\n            return FaustCompiler.gFactories.get(shaKey) || null;\n        } else {\n            try {\n                // Can possibly raise a C++ exception catched by the second catch()\n                const faustDspWasm = this.fLibFaust.createDSPFactory(\n                    name,\n                    code,\n                    args,\n                    !poly\n                );\n                const ui8Code = this.intVec2intArray(faustDspWasm.data);\n                faustDspWasm.data.delete();\n                const module = await WebAssembly.compile(ui8Code);\n                const factory: FaustDspFactory = {\n                    shaKey,\n                    cfactory: faustDspWasm.cfactory,\n                    code: ui8Code,\n                    module,\n                    json: faustDspWasm.json,\n                    poly,\n                    soundfiles: {}\n                };\n                // Factory C++ side can be deallocated immediately\n                this.deleteDSPFactory(factory);\n                // Keep the compiled factory in the cache\n                FaustCompiler.gFactories.set(shaKey, factory);\n                return factory;\n            } catch (e) {\n                this.fErrorMessage = this.fLibFaust.getErrorAfterException();\n                // console.error(`=> exception raised while running createDSPFactory: ${this.fErrorMessage}`, e);\n                this.fLibFaust.cleanupAfterException();\n                throw this.fErrorMessage ? new Error(this.fErrorMessage) : e;\n            }\n        }\n    }\n    version() {\n        return this.fLibFaust.version();\n    }\n    getErrorMessage() {\n        return this.fErrorMessage;\n    }\n    async createMonoDSPFactory(name: string, code: string, args: string) {\n        return this.createDSPFactory(name, code, args, false);\n    }\n    async createPolyDSPFactory(name: string, code: string, args: string) {\n        return this.createDSPFactory(name, code, args, true);\n    }\n    deleteDSPFactory(factory: FaustDspFactory) {\n        this.fLibFaust.deleteDSPFactory(factory.cfactory);\n        factory.cfactory = 0;\n    }\n    expandDSP(code: string, args: string) {\n        try {\n            return this.fLibFaust.expandDSP('FaustDSP', code, args);\n        } catch (e) {\n            this.fErrorMessage = this.fLibFaust.getErrorAfterException();\n            // console.error(`=> exception raised while running expandDSP: ${this.fErrorMessage}`);\n            this.fLibFaust.cleanupAfterException();\n            throw this.fErrorMessage ? new Error(this.fErrorMessage) : e;\n        }\n    }\n    generateAuxFiles(name: string, code: string, args: string) {\n        try {\n            return this.fLibFaust.generateAuxFiles(name, code, args);\n        } catch (e) {\n            this.fErrorMessage = this.fLibFaust.getErrorAfterException();\n            // console.error(`=> exception raised while running generateAuxFiles: ${this.fErrorMessage}`);\n            this.fLibFaust.cleanupAfterException();\n            throw this.fErrorMessage ? new Error(this.fErrorMessage) : e;\n        }\n    }\n    deleteAllDSPFactories(): void {\n        this.fLibFaust.deleteAllDSPFactories();\n    }\n    fs() {\n        return this.fLibFaust.fs();\n    }\n    async getAsyncInternalMixerModule(isDouble = false) {\n        const bufferKey = isDouble ? 'mixer64Buffer' : 'mixer32Buffer';\n        const moduleKey = isDouble ? 'mixer64Module' : 'mixer32Module';\n        if (this[moduleKey])\n            return {\n                mixerBuffer: this[bufferKey],\n                mixerModule: this[moduleKey]\n            };\n        const path = isDouble\n            ? '/usr/rsrc/mixer64.wasm'\n            : '/usr/rsrc/mixer32.wasm';\n        const mixerBuffer = this.fs().readFile(path, { encoding: 'binary' });\n        this[bufferKey] = mixerBuffer;\n        // Compile mixer\n        const mixerModule = await WebAssembly.compile(\n            new Uint8Array(mixerBuffer)\n        );\n        this[moduleKey] = mixerModule;\n        return { mixerBuffer, mixerModule };\n    }\n    getSyncInternalMixerModule(isDouble = false) {\n        const bufferKey = isDouble ? 'mixer64Buffer' : 'mixer32Buffer';\n        const moduleKey = isDouble ? 'mixer64Module' : 'mixer32Module';\n        if (this[moduleKey])\n            return {\n                mixerBuffer: this[bufferKey],\n                mixerModule: this[moduleKey]\n            };\n        const path = isDouble\n            ? '/usr/rsrc/mixer64.wasm'\n            : '/usr/rsrc/mixer32.wasm';\n        const mixerBuffer = this.fs().readFile(path, { encoding: 'binary' });\n        this[bufferKey] = mixerBuffer;\n        // Compile mixer\n        const mixerModule = new WebAssembly.Module(new Uint8Array(mixerBuffer));\n        this[moduleKey] = mixerModule;\n        return { mixerBuffer, mixerModule };\n    }\n}\n\nexport default FaustCompiler;\n", "/**\n * The Faust wasm instance interface.\n */\nexport interface IFaustDspInstance {\n    /**\n     * The dsp computation, to be called with successive input/output audio buffers.\n     *\n     * @param $dsp - the DSP pointer\n     * @param count - the audio buffer size in frames\n     * @param $inputs - the input audio buffer as in index in wasm memory\n     * @param $output - the output audio buffer as in index in wasm memory\n     */\n    compute(\n        $dsp: number,\n        count: number,\n        $inputs: number,\n        $output: number\n    ): void;\n\n    /**\n     * Give the number of inputs of a Faust wasm instance.\n     *\n     * @param $dsp - the DSP pointer\n     */\n    getNumInputs($dsp: number): number;\n\n    /**\n     * Give the number of outputs of a Faust wasm instance.\n     *\n     * @param $dsp - the DSP pointer\n     */\n    getNumOutputs($dsp: number): number;\n\n    /**\n     * Give a parameter current value.\n     *\n     * @param $dsp - the DSP pointer\n     * @param index - the parameter index\n     * @return the parameter value\n     */\n    getParamValue($dsp: number, index: number): number;\n\n    /**\n     * Give the Faust wasm instance sample rate.\n     *\n     * @param $dsp - the DSP pointer\n     * @return the sample rate\n     */\n    getSampleRate($dsp: number): number;\n\n    /**\n     * Global init, calls the following methods:\n     * - static class 'classInit': static tables initialization\n     * - 'instanceInit': constants and instance state initialization\n     *\n     * @param $dsp - the DSP pointer\n     * @param sampleRate - the sampling rate in Hertz\n     */\n    init($dsp: number, sampleRate: number): void;\n\n    /** Init instance state (delay lines...).\n     *\n     * @param $dsp - the DSP pointer\n     */\n    instanceClear($dsp: number): void;\n\n    /** Init instance constant state.\n     *\n     * @param $dsp - the DSP pointer\n     * @param sampleRate - the sampling rate in Hertz\n     */\n    instanceConstants($dsp: number, sampleRate: number): void;\n\n    /** Init instance state.\n     *\n     * @param $dsp - the DSP pointer\n     * @param sampleRate - the sampling rate in Hertz\n     */\n    instanceInit($dsp: number, sampleRate: number): void;\n\n    /** Init default control parameters values.\n     *\n     * @param $dsp - the DSP pointer\n     */\n    instanceResetUserInterface($dsp: number): void;\n\n    /**\n     * Set a parameter current value.\n     *\n     * @param $dsp - the DSP pointer\n     * @param index - the parameter index\n     * @param value - the parameter value\n     */\n    setParamValue($dsp: number, index: number, value: number): void;\n}\n\n/**\n * Mixer used in polyphonic mode.\n */\nexport interface IFaustMixerInstance {\n    clearOutput(bufferSize: number, chans: number, $outputs: number): void;\n    mixCheckVoice(\n        bufferSize: number,\n        chans: number,\n        $inputs: number,\n        $outputs: number\n    ): number;\n    fadeOut(bufferSize: number, chans: number, $outputs: number): void;\n}\n\n/**\n * Monophonic instance.\n */\nexport interface FaustMonoDspInstance {\n    memory: WebAssembly.Memory;\n    api: IFaustDspInstance;\n    json: string;\n}\n\n/**\n * Polyphonic instance.\n */\nexport interface FaustPolyDspInstance {\n    memory: WebAssembly.Memory;\n    voices: number;\n    voiceAPI: IFaustDspInstance;\n    effectAPI?: IFaustDspInstance;\n    mixerAPI: IFaustMixerInstance;\n    voiceJSON: string;\n    effectJSON?: string;\n}\n\nexport class FaustDspInstance implements IFaustDspInstance {\n    private readonly fExports: IFaustDspInstance;\n\n    constructor(exports: IFaustDspInstance) {\n        this.fExports = exports;\n    }\n\n    compute($dsp: number, count: number, $input: number, $output: number) {\n        this.fExports.compute($dsp, count, $input, $output);\n    }\n    getNumInputs($dsp: number) {\n        return this.fExports.getNumInputs($dsp);\n    }\n    getNumOutputs($dsp: number) {\n        return this.fExports.getNumOutputs($dsp);\n    }\n    getParamValue($dsp: number, index: number) {\n        return this.fExports.getParamValue($dsp, index);\n    }\n    getSampleRate($dsp: number) {\n        return this.fExports.getSampleRate($dsp);\n    }\n    init($dsp: number, sampleRate: number) {\n        this.fExports.init($dsp, sampleRate);\n    }\n    instanceClear($dsp: number) {\n        this.fExports.instanceClear($dsp);\n    }\n    instanceConstants($dsp: number, sampleRate: number) {\n        this.fExports.instanceConstants($dsp, sampleRate);\n    }\n    instanceInit($dsp: number, sampleRate: number) {\n        this.fExports.instanceInit($dsp, sampleRate);\n    }\n    instanceResetUserInterface($dsp: number) {\n        this.fExports.instanceResetUserInterface($dsp);\n    }\n    setParamValue($dsp: number, index: number, value: number) {\n        this.fExports.setParamValue($dsp, index, value);\n    }\n}\n", "import {\n    FaustDspInstance,\n    FaustMonoDspInstance,\n    FaustPolyDspInstance,\n    IFaustDspInstance,\n    IFaustMixerInstance\n} from './FaustDspInstance';\nimport type {\n    FaustDspFactory,\n    FaustDspMeta,\n    LooseFaustDspFactory\n} from './types';\n\nclass FaustWasmInstantiator {\n    private static createWasmImport(memory?: WebAssembly.Memory) {\n        return {\n            env: {\n                memory: memory || new WebAssembly.Memory({ initial: 100 }),\n                memoryBase: 0,\n                tableBase: 0,\n                // Integer version\n                _abs: Math.abs,\n                // Float version\n                _acosf: Math.acos,\n                _asinf: Math.asin,\n                _atanf: Math.atan,\n                _atan2f: Math.atan2,\n                _ceilf: Math.ceil,\n                _cosf: Math.cos,\n                _expf: Math.exp,\n                _floorf: Math.floor,\n                _fmodf: (x: number, y: number) => x % y,\n                _logf: Math.log,\n                _log10f: Math.log10,\n                _max_f: Math.max,\n                _min_f: Math.min,\n                _remainderf: (x: number, y: number) =>\n                    x - Math.round(x / y) * y,\n                _powf: Math.pow,\n                _roundf: Math.round,\n                _sinf: Math.sin,\n                _sqrtf: Math.sqrt,\n                _tanf: Math.tan,\n                _acoshf: Math.acosh,\n                _asinhf: Math.asinh,\n                _atanhf: Math.atanh,\n                _coshf: Math.cosh,\n                _sinhf: Math.sinh,\n                _tanhf: Math.tanh,\n                _isnanf: Number.isNaN,\n                _isinff: (x: number) => !isFinite(x),\n                _copysignf: (x: number, y: number) =>\n                    Math.sign(x) === Math.sign(y) ? x : -x,\n\n                // Double version\n                _acos: Math.acos,\n                _asin: Math.asin,\n                _atan: Math.atan,\n                _atan2: Math.atan2,\n                _ceil: Math.ceil,\n                _cos: Math.cos,\n                _exp: Math.exp,\n                _floor: Math.floor,\n                _fmod: (x: number, y: number) => x % y,\n                _log: Math.log,\n                _log10: Math.log10,\n                _max_: Math.max,\n                _min_: Math.min,\n                _remainder: (x: number, y: number) => x - Math.round(x / y) * y,\n                _pow: Math.pow,\n                _round: Math.round,\n                _sin: Math.sin,\n                _sqrt: Math.sqrt,\n                _tan: Math.tan,\n                _acosh: Math.acosh,\n                _asinh: Math.asinh,\n                _atanh: Math.atanh,\n                _cosh: Math.cosh,\n                _sinh: Math.sinh,\n                _tanh: Math.tanh,\n                _isnan: Number.isNaN,\n                _isinf: (x: number) => !isFinite(x),\n                _copysign: (x: number, y: number) =>\n                    Math.sign(x) === Math.sign(y) ? x : -x,\n\n                table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' })\n            }\n        };\n    }\n    private static createWasmMemoryPoly(\n        voicesIn: number,\n        sampleSize: number,\n        dspMeta: FaustDspMeta,\n        effectMeta: FaustDspMeta,\n        bufferSize: number\n    ) {\n        // Hack : at least 4 voices (to avoid weird wasm memory bug?)\n        const voices = Math.max(4, voicesIn);\n        // Memory allocator\n        const ptrSize = sampleSize; // Done on wast/wasm backend side\n        const pow2limit = (x: number) => {\n            let n = 65536; // Minimum = 64 kB\n            while (n < x) {\n                n *= 2;\n            }\n            return n;\n        };\n        const effectSize = effectMeta ? effectMeta.size : 0;\n        let memorySize =\n            pow2limit(\n                effectSize +\n                    dspMeta.size * voices +\n                    (dspMeta.inputs + dspMeta.outputs * 2) * // + 2 for effect\n                        (ptrSize + bufferSize * sampleSize)\n            ) / 65536;\n        memorySize = Math.max(2, memorySize); // At least 2\n        return new WebAssembly.Memory({ initial: memorySize });\n    }\n\n    private static createWasmMemoryMono(\n        sampleSize: number,\n        dspMeta: FaustDspMeta,\n        bufferSize: number\n    ) {\n        // Memory allocator\n        const ptrSize = sampleSize; // Done on wast/wasm backend side\n        const memorySize =\n            (dspMeta.size +\n                (dspMeta.inputs + dspMeta.outputs) *\n                    (ptrSize + bufferSize * sampleSize)) /\n            65536;\n        return new WebAssembly.Memory({ initial: memorySize * 2 }); // Safer to have a bit more memory\n    }\n\n    private static createMonoDSPInstanceAux(\n        instance: WebAssembly.Instance,\n        json: string,\n        mem: WebAssembly.Memory | null = null\n    ) {\n        const functions = instance.exports as IFaustDspInstance &\n            WebAssembly.Exports;\n        const api = new FaustDspInstance(functions);\n        const memory: any = mem ? mem : instance.exports.memory;\n        return { memory, api, json } as FaustMonoDspInstance;\n    }\n\n    private static createMemoryMono(monoFactory: LooseFaustDspFactory) {\n        // Parse JSON to get 'size' and 'inputs/outputs' infos\n        const monoMeta: FaustDspMeta = JSON.parse(monoFactory.json);\n        const sampleSize = monoMeta.compile_options.match('-double') ? 8 : 4;\n        return this.createWasmMemoryMono(sampleSize, monoMeta, 8192);\n    }\n    private static createMemoryPoly(\n        voices: number,\n        voiceFactory: LooseFaustDspFactory,\n        effectFactory?: LooseFaustDspFactory\n    ) {\n        // Parse JSON to get 'size' and 'inputs/outputs' infos\n        const voiceMeta: FaustDspMeta = JSON.parse(voiceFactory.json);\n        const effectMeta: FaustDspMeta =\n            effectFactory && effectFactory.json\n                ? JSON.parse(effectFactory.json)\n                : null;\n        const sampleSize = voiceMeta.compile_options.match('-double') ? 8 : 4;\n        // Memory will be shared by voice, mixer and (possibly) effect instances\n        return this.createWasmMemoryPoly(\n            voices,\n            sampleSize,\n            voiceMeta,\n            effectMeta,\n            8192\n        );\n    }\n\n    private static createMixerAux(\n        mixerModule: WebAssembly.Module,\n        memory: WebAssembly.Memory\n    ) {\n        // Create mixer instance\n        const mixerImport = {\n            imports: { print: console.log },\n            memory: { memory }\n        };\n        const mixerInstance = new WebAssembly.Instance(\n            mixerModule,\n            mixerImport\n        );\n        const mixerFunctions = mixerInstance.exports as IFaustMixerInstance &\n            WebAssembly.Exports;\n        return mixerFunctions;\n    }\n\n    // Public API\n    static async loadDSPFactory(wasmPath: string, jsonPath: string) {\n        const wasmFile = await fetch(wasmPath);\n        if (!wasmFile.ok) {\n            throw new Error(\n                `=> exception raised while running loadDSPFactory, file not found: ${wasmPath}`\n            );\n        }\n        try {\n            const wasmBuffer = await wasmFile.arrayBuffer();\n            const module = await WebAssembly.compile(wasmBuffer);\n            const jsonFile = await fetch(jsonPath);\n            const json = await jsonFile.text();\n            const meta: FaustDspMeta = JSON.parse(json);\n            const cOptions = meta.compile_options;\n            const poly = cOptions.indexOf('wasm-e') !== -1;\n            return {\n                cfactory: 0,\n                code: new Uint8Array(wasmBuffer),\n                module,\n                json,\n                poly\n            } as FaustDspFactory;\n        } catch (e) {\n            // console.error(`=> exception raised while running loadDSPFactory: ${e}`);\n            throw e;\n        }\n    }\n\n    static async loadDSPMixer(mixerPath: string, fs?: typeof FS) {\n        try {\n            let mixerBuffer: BufferSource | null = null;\n            if (fs) {\n                mixerBuffer = new Uint8Array(\n                    fs.readFile(mixerPath, { encoding: 'binary' })\n                );\n            } else {\n                const mixerFile = await fetch(mixerPath);\n                mixerBuffer = await mixerFile.arrayBuffer();\n            }\n            // Compile mixer\n            return WebAssembly.compile(mixerBuffer);\n        } catch (e) {\n            // console.error(`=> exception raised while running loadMixer: ${e}`);\n            throw e;\n        }\n    }\n\n    static async createAsyncMonoDSPInstance(factory: LooseFaustDspFactory) {\n        // Regular expression to match the 'type: soundfile' pattern\n        const pattern = /\"type\":\\s*\"soundfile\"/;\n        // Check if the pattern exists in the JSON string\n        const isDetected = pattern.test(factory.json);\n\n        if (isDetected) {\n            const memory = this.createMemoryMono(factory);\n            const instance = await WebAssembly.instantiate(\n                factory.module,\n                this.createWasmImport(memory)\n            );\n            return this.createMonoDSPInstanceAux(\n                instance,\n                factory.json,\n                memory\n            );\n        } else {\n            // Otherwise, we can create the instance using the wasm internal memory allocated by the wasm module\n            const instance = await WebAssembly.instantiate(\n                factory.module,\n                this.createWasmImport()\n            );\n            return this.createMonoDSPInstanceAux(instance, factory.json);\n        }\n    }\n\n    static createSyncMonoDSPInstance(factory: LooseFaustDspFactory) {\n        // Regular expression to match the 'type: soundfile' pattern\n        const pattern = /\"type\":\\s*\"soundfile\"/;\n        // Check if the pattern exists in the JSON string\n        const isDetected = pattern.test(factory.json);\n\n        // If the JSON contains a soundfile UI element, we need to create a memory object\n        if (isDetected) {\n            const memory = this.createMemoryMono(factory);\n            const instance = new WebAssembly.Instance(\n                factory.module,\n                this.createWasmImport(memory)\n            );\n            return this.createMonoDSPInstanceAux(\n                instance,\n                factory.json,\n                memory\n            );\n        } else {\n            // Otherwise, we can create the instance using the wasm internal memory allocated by the wasm module\n            const instance = new WebAssembly.Instance(\n                factory.module,\n                this.createWasmImport()\n            );\n            return this.createMonoDSPInstanceAux(instance, factory.json);\n        }\n    }\n\n    static async createAsyncPolyDSPInstance(\n        voiceFactory: LooseFaustDspFactory,\n        mixerModule: WebAssembly.Module,\n        voices: number,\n        effectFactory?: LooseFaustDspFactory\n    ): Promise<FaustPolyDspInstance> {\n        const memory = this.createMemoryPoly(\n            voices,\n            voiceFactory,\n            effectFactory\n        );\n        // Create voice\n        const voiceInstance = await WebAssembly.instantiate(\n            voiceFactory.module,\n            this.createWasmImport(memory)\n        );\n        const voiceFunctions = voiceInstance.exports as IFaustDspInstance &\n            WebAssembly.Exports;\n        const voiceAPI = new FaustDspInstance(voiceFunctions);\n        // Create mixer\n        const mixerAPI = this.createMixerAux(mixerModule, memory);\n\n        // Possibly create effect instance\n        if (effectFactory) {\n            const effectInstance = await WebAssembly.instantiate(\n                effectFactory.module,\n                this.createWasmImport(memory)\n            );\n            const effectFunctions =\n                effectInstance.exports as IFaustDspInstance &\n                    WebAssembly.Exports;\n            const effectAPI = new FaustDspInstance(effectFunctions);\n            return {\n                memory,\n                voices,\n                voiceAPI,\n                effectAPI,\n                mixerAPI,\n                voiceJSON: voiceFactory.json,\n                effectJSON: effectFactory.json\n            } as FaustPolyDspInstance;\n        } else {\n            return {\n                memory,\n                voices,\n                voiceAPI,\n                mixerAPI,\n                voiceJSON: voiceFactory.json\n            } as FaustPolyDspInstance;\n        }\n    }\n\n    static createSyncPolyDSPInstance(\n        voiceFactory: LooseFaustDspFactory,\n        mixerModule: WebAssembly.Module,\n        voices: number,\n        effectFactory?: LooseFaustDspFactory\n    ): FaustPolyDspInstance {\n        const memory = this.createMemoryPoly(\n            voices,\n            voiceFactory,\n            effectFactory\n        );\n        // Create voice\n        const voiceInstance = new WebAssembly.Instance(\n            voiceFactory.module,\n            this.createWasmImport(memory)\n        );\n        const voiceFunctions = voiceInstance.exports as IFaustDspInstance &\n            WebAssembly.Exports;\n        const voiceAPI = new FaustDspInstance(voiceFunctions);\n        // Create mixer\n        const mixerAPI = this.createMixerAux(mixerModule, memory);\n\n        // Possibly create effect instance\n        if (effectFactory) {\n            const effectInstance = new WebAssembly.Instance(\n                effectFactory.module,\n                this.createWasmImport(memory)\n            );\n            const effectFunctions =\n                effectInstance.exports as IFaustDspInstance &\n                    WebAssembly.Exports;\n            const effectAPI = new FaustDspInstance(effectFunctions);\n            return {\n                memory,\n                voices,\n                voiceAPI,\n                effectAPI,\n                mixerAPI,\n                voiceJSON: voiceFactory.json,\n                effectJSON: effectFactory.json\n            } as FaustPolyDspInstance;\n        } else {\n            return {\n                memory,\n                voices,\n                voiceAPI,\n                mixerAPI,\n                voiceJSON: voiceFactory.json\n            } as FaustPolyDspInstance;\n        }\n    }\n}\n\nexport default FaustWasmInstantiator;\n", "\uFEFFexport interface AccParams {\n    isEnabled: boolean;\n    acc: string;\n    address: string;\n    min: number;\n    max: number;\n    init: number;\n    label: string;\n}\n\n/** Enum describing the axis of the accelerometer or gyroscope */\nexport enum Axis {\n    x,\n    y,\n    z\n}\n\n/** Enum describing the curve of the accelerometer */\nexport enum Curve {\n    Up,\n    Down,\n    UpDown,\n    DownUp\n}\n\ninterface Range {\n    fLo: number;\n    fHi: number;\n    clip(x: number): number;\n}\n\ninterface InterpolateObject {\n    amin: number;\n    amax: number;\n}\ninterface Interpolator {\n    fRange: Range;\n    fCoef: number;\n    fOffset: number;\n    returnMappedValue(v: number): number;\n    getLowHigh(amin: number, amax: number): InterpolateObject;\n}\n\ninterface InterpolateObject3pt {\n    amin: number;\n    amid: number;\n    amax: number;\n}\ninterface Interpolator3pt {\n    fSegment1: Interpolator;\n    fSegment2: Interpolator;\n    fMid: number;\n    returnMappedValue(v: number): number;\n    getMappingValues(\n        amin: number,\n        amid: number,\n        amax: number\n    ): InterpolateObject3pt;\n}\n\n/**\n * ValueConverter interface\n */\ninterface ValueConverter {\n    uiToFaust(x: number): number;\n    faustToUi(x: number): number;\n}\n\n/**\n * UpdatableValueConverter interface\n */\nexport interface UpdatableValueConverter extends ValueConverter {\n    fActive: boolean;\n\n    setMappingValues(\n        amin: number,\n        amid: number,\n        amax: number,\n        min: number,\n        init: number,\n        max: number\n    ): void;\n    getMappingValues(\n        amin: number,\n        amid: number,\n        amax: number\n    ): InterpolateObject3pt;\n\n    setActive(onOff: boolean): void;\n    getActive(): boolean;\n}\n\nexport default class FaustSensors {\n    /**\n     * Function to convert a number to an axis type\n     *\n     * @param value number\n     * @returns axis type\n     */\n    static convertToAxis(value: number): Axis {\n        switch (value) {\n            case 0:\n                return Axis.x;\n            case 1:\n                return Axis.y;\n            case 2:\n                return Axis.z;\n            default:\n                console.error('Error: Axis not found value: ' + value);\n                return Axis.x;\n        }\n    }\n    /**\n     * Function to convert a number to a curve type\n     *\n     * @param value number\n     * @returns curve type\n     */\n    static convertToCurve(value: number): Curve {\n        switch (value) {\n            case 0:\n                return Curve.Up;\n            case 1:\n                return Curve.Down;\n            case 2:\n                return Curve.UpDown;\n            case 3:\n                return Curve.DownUp;\n            default:\n                console.error('Error: Curve not found value: ' + value);\n                return Curve.Up;\n        }\n    }\n\n    // Converter objects use to map acc and Faust value\n    static _Range: new (x: number, y: number) => Range;\n    static get Range() {\n        if (!this._Range) {\n            this._Range = class {\n                fLo: number;\n                fHi: number;\n\n                constructor(x: number, y: number) {\n                    this.fLo = Math.min(x, y);\n                    this.fHi = Math.max(x, y);\n                }\n\n                clip(x: number): number {\n                    if (x < this.fLo) return this.fLo;\n                    if (x > this.fHi) return this.fHi;\n                    return x;\n                }\n            };\n        }\n        return this._Range;\n    }\n\n    static _Interpolator: new (\n        lo: number,\n        hi: number,\n        v1: number,\n        v2: number\n    ) => Interpolator;\n    /**\n     * Interpolator class\n     */\n    static get Interpolator() {\n        if (!this._Interpolator) {\n            this._Interpolator = class {\n                fRange: Range;\n                fCoef: number;\n                fOffset: number;\n\n                constructor(lo: number, hi: number, v1: number, v2: number) {\n                    this.fRange = new FaustSensors.Range(lo, hi);\n                    if (hi !== lo) {\n                        // regular case\n                        this.fCoef = (v2 - v1) / (hi - lo);\n                        this.fOffset = v1 - lo * this.fCoef;\n                    } else {\n                        // degenerate case, avoids division by zero\n                        this.fCoef = 0;\n                        this.fOffset = (v1 + v2) / 2;\n                    }\n                }\n                returnMappedValue(v: number): number {\n                    const x = this.fRange.clip(v);\n                    return this.fOffset + x * this.fCoef;\n                }\n                getLowHigh(amin: number, amax: number): InterpolateObject {\n                    return { amin: this.fRange.fLo, amax: this.fRange.fHi };\n                }\n            };\n        }\n        return this._Interpolator;\n    }\n\n    static _Interpolator3pt: new (\n        lo: number,\n        mid: number,\n        hi: number,\n        v1: number,\n        vMid: number,\n        v2: number\n    ) => Interpolator3pt;\n    /**\n     * Interpolator3pt class, combine two interpolators\n     */\n    static get Interpolator3pt() {\n        if (!this._Interpolator3pt) {\n            this._Interpolator3pt = class {\n                fSegment1: Interpolator;\n                fSegment2: Interpolator;\n                fMid: number;\n\n                constructor(\n                    lo: number,\n                    mid: number,\n                    hi: number,\n                    v1: number,\n                    vMid: number,\n                    v2: number\n                ) {\n                    this.fSegment1 = new FaustSensors.Interpolator(\n                        lo,\n                        mid,\n                        v1,\n                        vMid\n                    );\n                    this.fSegment2 = new FaustSensors.Interpolator(\n                        mid,\n                        hi,\n                        vMid,\n                        v2\n                    );\n                    this.fMid = mid;\n                }\n                returnMappedValue(x: number): number {\n                    return x < this.fMid\n                        ? this.fSegment1.returnMappedValue(x)\n                        : this.fSegment2.returnMappedValue(x);\n                }\n\n                getMappingValues(\n                    amin: number,\n                    amid: number,\n                    amax: number\n                ): InterpolateObject3pt {\n                    const lowHighSegment1 = this.fSegment1.getLowHigh(\n                        amin,\n                        amid\n                    );\n                    const lowHighSegment2 = this.fSegment2.getLowHigh(\n                        amid,\n                        amax\n                    );\n                    return {\n                        amin: lowHighSegment1.amin,\n                        amid: lowHighSegment2.amin,\n                        amax: lowHighSegment2.amax\n                    };\n                }\n            };\n        }\n        return this._Interpolator3pt;\n    }\n    static _UpConverter: new (\n        amin: number,\n        amid: number,\n        amax: number,\n        fmin: number,\n        fmid: number,\n        fmax: number\n    ) => UpdatableValueConverter;\n    /**\n     * UpConverter class, convert accelerometer value to Faust value\n     */\n    static get UpConverter() {\n        if (!this._UpConverter) {\n            this._UpConverter = class implements UpdatableValueConverter {\n                fA2F: Interpolator3pt;\n                fF2A: Interpolator3pt;\n                fActive: boolean = true;\n\n                constructor(\n                    amin: number,\n                    amid: number,\n                    amax: number,\n                    fmin: number,\n                    fmid: number,\n                    fmax: number\n                ) {\n                    this.fA2F = new FaustSensors.Interpolator3pt(\n                        amin,\n                        amid,\n                        amax,\n                        fmin,\n                        fmid,\n                        fmax\n                    );\n                    this.fF2A = new FaustSensors.Interpolator3pt(\n                        fmin,\n                        fmid,\n                        fmax,\n                        amin,\n                        amid,\n                        amax\n                    );\n                }\n\n                uiToFaust(x: number) {\n                    return this.fA2F.returnMappedValue(x);\n                }\n                faustToUi(x: number) {\n                    return this.fF2A.returnMappedValue(x);\n                }\n\n                setMappingValues(\n                    amin: number,\n                    amid: number,\n                    amax: number,\n                    min: number,\n                    init: number,\n                    max: number\n                ): void {\n                    this.fA2F = new FaustSensors.Interpolator3pt(\n                        amin,\n                        amid,\n                        amax,\n                        min,\n                        init,\n                        max\n                    );\n                    this.fF2A = new FaustSensors.Interpolator3pt(\n                        min,\n                        init,\n                        max,\n                        amin,\n                        amid,\n                        amax\n                    );\n                }\n\n                getMappingValues(\n                    amin: number,\n                    amid: number,\n                    amax: number\n                ): InterpolateObject3pt {\n                    return this.fA2F.getMappingValues(amin, amid, amax);\n                }\n\n                setActive(onOff: boolean): void {\n                    this.fActive = onOff;\n                }\n                getActive(): boolean {\n                    return this.fActive;\n                }\n            };\n        }\n        return this._UpConverter;\n    }\n    static _DownConverter: new (\n        amin: number,\n        amid: number,\n        amax: number,\n        fmin: number,\n        fmid: number,\n        fmax: number\n    ) => UpdatableValueConverter;\n    /**\n     * DownConverter class, convert accelerometer value to Faust value\n     */\n    static get DownConverter() {\n        if (!this._DownConverter) {\n            this._DownConverter = class implements UpdatableValueConverter {\n                fA2F: Interpolator3pt;\n                fF2A: Interpolator3pt;\n                fActive: boolean = true;\n\n                constructor(\n                    amin: number,\n                    amid: number,\n                    amax: number,\n                    fmin: number,\n                    fmid: number,\n                    fmax: number\n                ) {\n                    this.fA2F = new FaustSensors.Interpolator3pt(\n                        amin,\n                        amid,\n                        amax,\n                        fmax,\n                        fmid,\n                        fmin\n                    );\n                    this.fF2A = new FaustSensors.Interpolator3pt(\n                        fmin,\n                        fmid,\n                        fmax,\n                        amax,\n                        amid,\n                        amin\n                    );\n                }\n\n                uiToFaust(x: number) {\n                    return this.fA2F.returnMappedValue(x);\n                }\n                faustToUi(x: number) {\n                    return this.fF2A.returnMappedValue(x);\n                }\n\n                setMappingValues(\n                    amin: number,\n                    amid: number,\n                    amax: number,\n                    min: number,\n                    init: number,\n                    max: number\n                ): void {\n                    this.fA2F = new FaustSensors.Interpolator3pt(\n                        amin,\n                        amid,\n                        amax,\n                        max,\n                        init,\n                        min\n                    );\n                    this.fF2A = new FaustSensors.Interpolator3pt(\n                        min,\n                        init,\n                        max,\n                        amax,\n                        amid,\n                        amin\n                    );\n                }\n                getMappingValues(\n                    amin: number,\n                    amid: number,\n                    amax: number\n                ): InterpolateObject3pt {\n                    return this.fA2F.getMappingValues(amin, amid, amax);\n                }\n\n                setActive(onOff: boolean): void {\n                    this.fActive = onOff;\n                }\n                getActive(): boolean {\n                    return this.fActive;\n                }\n            };\n        }\n        return this._DownConverter;\n    }\n    static _UpDownConverter: new (\n        amin: number,\n        amid: number,\n        amax: number,\n        fmin: number,\n        fmid: number,\n        fmax: number\n    ) => UpdatableValueConverter;\n    /**\n     * UpDownConverter class, convert accelerometer value to Faust value\n     */\n    static get UpDownConverter() {\n        if (!this._UpDownConverter) {\n            this._UpDownConverter = class implements UpdatableValueConverter {\n                fA2F: Interpolator3pt;\n                fF2A: Interpolator;\n                fActive: boolean = true;\n\n                constructor(\n                    amin: number,\n                    amid: number,\n                    amax: number,\n                    fmin: number,\n                    fmid: number,\n                    fmax: number\n                ) {\n                    this.fA2F = new FaustSensors.Interpolator3pt(\n                        amin,\n                        amid,\n                        amax,\n                        fmin,\n                        fmax,\n                        fmin\n                    );\n                    this.fF2A = new FaustSensors.Interpolator(\n                        fmin,\n                        fmax,\n                        amin,\n                        amax\n                    );\n                }\n\n                uiToFaust(x: number) {\n                    return this.fA2F.returnMappedValue(x);\n                }\n                faustToUi(x: number) {\n                    return this.fF2A.returnMappedValue(x);\n                }\n\n                setMappingValues(\n                    amin: number,\n                    amid: number,\n                    amax: number,\n                    min: number,\n                    init: number,\n                    max: number\n                ): void {\n                    this.fA2F = new FaustSensors.Interpolator3pt(\n                        amin,\n                        amid,\n                        amax,\n                        min,\n                        max,\n                        min\n                    );\n                    this.fF2A = new FaustSensors.Interpolator(\n                        min,\n                        max,\n                        amin,\n                        amax\n                    );\n                }\n                getMappingValues(\n                    amin: number,\n                    amid: number,\n                    amax: number\n                ): InterpolateObject3pt {\n                    return this.fA2F.getMappingValues(amin, amid, amax);\n                }\n\n                setActive(onOff: boolean): void {\n                    this.fActive = onOff;\n                }\n                getActive(): boolean {\n                    return this.fActive;\n                }\n            };\n        }\n        return this._UpDownConverter;\n    }\n    /**\n     * DownUpConverter class, convert accelerometer value to Faust value\n     */\n    static _DownUpConverter: new (\n        amin: number,\n        amid: number,\n        amax: number,\n        fmin: number,\n        fmid: number,\n        fmax: number\n    ) => UpdatableValueConverter;\n    static get DownUpConverter() {\n        if (!this._DownUpConverter) {\n            this._DownUpConverter = class implements UpdatableValueConverter {\n                fA2F: Interpolator3pt;\n                fF2A: Interpolator;\n                fActive: boolean = true;\n\n                constructor(\n                    amin: number,\n                    amid: number,\n                    amax: number,\n                    fmin: number,\n                    fmid: number,\n                    fmax: number\n                ) {\n                    this.fA2F = new FaustSensors.Interpolator3pt(\n                        amin,\n                        amid,\n                        amax,\n                        fmax,\n                        fmin,\n                        fmax\n                    );\n                    this.fF2A = new FaustSensors.Interpolator(\n                        fmin,\n                        fmax,\n                        amin,\n                        amax\n                    );\n                }\n\n                uiToFaust(x: number) {\n                    return this.fA2F.returnMappedValue(x);\n                }\n                faustToUi(x: number) {\n                    return this.fF2A.returnMappedValue(x);\n                }\n\n                setMappingValues(\n                    amin: number,\n                    amid: number,\n                    amax: number,\n                    min: number,\n                    init: number,\n                    max: number\n                ): void {\n                    this.fA2F = new FaustSensors.Interpolator3pt(\n                        amin,\n                        amid,\n                        amax,\n                        max,\n                        min,\n                        max\n                    );\n                    this.fF2A = new FaustSensors.Interpolator(\n                        min,\n                        max,\n                        amin,\n                        amax\n                    );\n                }\n                getMappingValues(\n                    amin: number,\n                    amid: number,\n                    amax: number\n                ): InterpolateObject3pt {\n                    return this.fA2F.getMappingValues(amin, amid, amax);\n                }\n\n                setActive(onOff: boolean): void {\n                    this.fActive = onOff;\n                }\n                getActive(): boolean {\n                    return this.fActive;\n                }\n            };\n        }\n        return this._DownUpConverter;\n    }\n    /**\n     * Public function to build the accelerometer handler\n     *\n     * @returns `UpdatableValueConverter` built for the given curve\n     */\n    static buildHandler(\n        curve: Curve,\n        amin: number,\n        amid: number,\n        amax: number,\n        min: number,\n        init: number,\n        max: number\n    ): UpdatableValueConverter {\n        switch (curve) {\n            case Curve.Up:\n                return new FaustSensors.UpConverter(\n                    amin,\n                    amid,\n                    amax,\n                    min,\n                    init,\n                    max\n                );\n            case Curve.Down:\n                return new FaustSensors.DownConverter(\n                    amin,\n                    amid,\n                    amax,\n                    min,\n                    init,\n                    max\n                );\n            case Curve.UpDown:\n                return new FaustSensors.UpDownConverter(\n                    amin,\n                    amid,\n                    amax,\n                    min,\n                    init,\n                    max\n                );\n            case Curve.DownUp:\n                return new FaustSensors.DownUpConverter(\n                    amin,\n                    amid,\n                    amax,\n                    min,\n                    init,\n                    max\n                );\n            default:\n                return new FaustSensors.UpConverter(\n                    amin,\n                    amid,\n                    amax,\n                    min,\n                    init,\n                    max\n                );\n        }\n    }\n}\n", "import type {\n    FaustMonoDspInstance,\n    FaustPolyDspInstance,\n    IFaustDspInstance\n} from './FaustDspInstance';\nimport type {\n    AudioData,\n    FaustDspMeta,\n    FaustUIDescriptor,\n    FaustUIGroup,\n    FaustUIInputItem,\n    FaustUIItem,\n    LooseFaustDspFactory\n} from './types';\nimport FaustSensors, {\n    Axis,\n    Curve,\n    UpdatableValueConverter\n} from './FaustSensors';\n\n// Public API\nexport type OutputParamHandler = (path: string, value: number) => void;\nexport type InputParamHandler = (path: string, value: number) => void;\nexport type ComputeHandler = (buffer_size: number) => void;\nexport type PlotHandler = (\n    plotted: Float32Array[] | Float64Array[],\n    index: number,\n    events?: { type: string; data: any }[]\n) => void;\nexport type MetadataHandler = (key: string, value: string) => void;\n\n// Implementation API\nexport type UIHandler = (item: FaustUIItem) => void;\n\n// Accelerometer or gyroscope handler\nexport type SensorEventHandler = (val: number) => void;\n\n// Define a type for the accelerometer or gyroscope handlers\nexport type SensorEventHandlers = {\n    x: SensorEventHandler[];\n    y: SensorEventHandler[];\n    z: SensorEventHandler[];\n};\n\n/** Definition of the AudioBufferItem type */\nexport interface AudioBufferItem {\n    pathName: string;\n    audioBuffer: AudioBuffer;\n}\n\n/** Definition of the SoundfileItem type */\nexport interface SoundfileItem {\n    /** Name of the soundfile */\n    name: string;\n    /** URL of the soundfile */\n    url: string;\n    /** Index in the DSP struct */\n    index: number;\n    /** Base pointer in wasm memory */\n    basePtr: number;\n}\n\n/**\n * WasmAllocator is a basic memory management class designed to allocate\n * blocks of memory within a WebAssembly.Memory object. It provides a simple\n * alloc method to allocate a contiguous block of memory of a specified size.\n *\n * The allocator operates by keeping a linear progression through the memory,\n * always allocating the next block at the end of the last. This approach does not\n * handle freeing of memory or reuse of memory spaces.\n */\nexport class WasmAllocator {\n    // The WebAssembly.Memory object this allocator will manage.\n    private readonly memory: WebAssembly.Memory;\n    // The number of bytes currently allocated. This serves as the \"pointer\" to the\n    // next free byte in the memory.\n    private allocatedBytes: number;\n\n    constructor(memory: WebAssembly.Memory, offset: number) {\n        this.memory = memory;\n        // Initialize the allocator with offset allocated bytes.\n        this.allocatedBytes = offset;\n    }\n\n    /**\n     * Allocates a block of memory of the specified size, returning the pointer to the\n     * beginning of the block. The block is allocated at the current offset and the\n     * offset is incremented by the size of the block.\n     *\n     * @param sizeInBytes The size of the block to allocate in bytes.\n     * @returns The offset (pointer) to the beginning of the allocated block.\n     */\n    alloc(sizeInBytes: number): number {\n        // Store the current offset as the start of the new block.\n        const currentOffset = this.allocatedBytes;\n        // Calculate the new offset after allocating the requested block.\n        const newOffset = currentOffset + sizeInBytes;\n        // Get the total size of the WebAssembly memory in bytes.\n        const totalMemoryBytes = this.memory.buffer.byteLength;\n\n        // If the new offset exceeds the total size of the memory, grow the memory.\n        if (newOffset > totalMemoryBytes) {\n            // Calculate the number of WebAssembly pages needed to fit the new allocation.\n            // WebAssembly memory pages are 64KiB each.\n            const neededPages = Math.ceil(\n                (newOffset - totalMemoryBytes) / 65536\n            );\n            // Grow the memory by the required number of pages.\n            console.log(`GROW: ${neededPages} pages`);\n            this.memory.grow(neededPages);\n        }\n\n        // Update the allocated bytes to the new offset.\n        this.allocatedBytes = newOffset;\n        // Return the offset at which the allocated block starts.\n        return currentOffset;\n    }\n\n    /**\n     * Returns the underlying buffer object.\n     *\n     * @returns The buffer object.\n     */\n    getBuffer(): ArrayBuffer {\n        return this.memory.buffer;\n    }\n\n    /**\n     * Returns the Int32 view of the underlying buffer object.\n     *\n     * @returns The view of the memory buffer as Int32Array.\n     */\n    getInt32Array(): Int32Array {\n        return new Int32Array(this.memory.buffer);\n    }\n\n    /**\n     * Returns the Int64 view of the underlying buffer object.\n     *\n     * @returns The view of the memory buffer as BigInt64Array.\n     */\n    getInt64Array(): BigInt64Array {\n        return new BigInt64Array(this.memory.buffer);\n    }\n\n    /**\n     * Returns the Float32 view of the underlying buffer object.\n     *\n     * @returns The view of the memory buffer as Float32Array.\n     */\n    getFloat32Array(): Float32Array {\n        return new Float32Array(this.memory.buffer);\n    }\n\n    /**\n     * Returns the Float64 view of the underlying buffer object..\n     *\n     * @returns The view of the memory buffer as Float64Array.\n     */\n    getFloat64Array(): Float64Array {\n        return new Float64Array(this.memory.buffer);\n    }\n}\n\n/**\n * Soundfile class to handle soundfile data in wasm memory.\n */\nexport class Soundfile {\n    /** Maximum number of soundfile parts. */\n    static get MAX_SOUNDFILE_PARTS() {\n        return 256;\n    }\n\n    /** Maximum number of channels. */\n    static get MAX_CHAN() {\n        return 64;\n    }\n\n    /** Maximum buffer size in frames. */\n    static get BUFFER_SIZE() {\n        return 1024;\n    }\n\n    /** Default sample rate. */\n    static get SAMPLE_RATE() {\n        return 44100;\n    }\n\n    /** Pointer to the soundfile structure in wasm memory */\n    private readonly fPtr: number;\n    private readonly fBuffers: number;\n    private readonly fLength: number;\n    private readonly fSR: number;\n    private readonly fOffset: number;\n    private readonly fSampleSize: number;\n    private readonly fPtrSize: number;\n    private readonly fIntSize: number;\n    private readonly fAllocator: WasmAllocator;\n\n    constructor(\n        allocator: WasmAllocator,\n        sampleSize: number,\n        curChan: number,\n        length: number,\n        maxChan: number,\n        totalParts: number\n    ) {\n        this.fSampleSize = sampleSize;\n\n        // To be coherent with the code generated by the wast/wasm backends:\n        // - that uses 4 bytes for int when float is used\n        // - that uses 8 bytes for int when double is used (to simplify the code generation)\n        this.fIntSize = this.fSampleSize;\n\n        this.fPtrSize = 4; // Not related to float/double choice, so always 4\n\n        this.fAllocator = allocator;\n\n        console.log(\n            `Soundfile constructor: curChan: ${curChan}, length: ${length}, maxChan: ${maxChan}, totalParts: ${totalParts}`\n        );\n\n        // Allocate wasm memory for the soundfile structure\n        this.fPtr = allocator.alloc(4 * this.fPtrSize); // 4 fPtrSize: fBuffers, fLength, fSR, fOffset\n\n        // Use the 4 or 8 bytes size for int. The access are then adapted in copyToOut and emptyFile methods\n        this.fLength = allocator.alloc(\n            Soundfile.MAX_SOUNDFILE_PARTS * this.fIntSize\n        );\n        this.fSR = allocator.alloc(\n            Soundfile.MAX_SOUNDFILE_PARTS * this.fIntSize\n        );\n        this.fOffset = allocator.alloc(\n            Soundfile.MAX_SOUNDFILE_PARTS * this.fIntSize\n        );\n\n        this.fBuffers = this.allocBuffers(curChan, length, maxChan);\n\n        //this.displayMemory(\"Allocated soundfile structure 1\");\n\n        // Set the soundfile structure in wasm memory\n        const HEAP32 = this.fAllocator.getInt32Array();\n        HEAP32[this.fPtr >> 2] = this.fBuffers;\n        HEAP32[(this.fPtr + this.fPtrSize) >> 2] = this.fLength;\n        HEAP32[(this.fPtr + 2 * this.fPtrSize) >> 2] = this.fSR;\n        HEAP32[(this.fPtr + 3 * this.fPtrSize) >> 2] = this.fOffset;\n\n        for (let chan = 0; chan < curChan; chan++) {\n            const buffer: number = HEAP32[(this.fBuffers >> 2) + chan];\n            console.log(`allocBuffers AFTER: ${chan} - ${buffer}`);\n        }\n\n        //this.displayMemory(\"Allocated soundfile structure 2\");\n    }\n\n    private allocBuffers(\n        curChan: number,\n        length: number,\n        maxChan: number\n    ): number {\n        const buffers = this.fAllocator.alloc(maxChan * this.fPtrSize);\n\n        console.log(`allocBuffers buffers: ${buffers}`);\n\n        for (let chan = 0; chan < curChan; chan++) {\n            const buffer: number = this.fAllocator.alloc(\n                length * this.fSampleSize\n            );\n            // HEAP32 is the Int32Array view of the memory buffer which can change after grow in `alloc` method\n            // so we need to recompute the buffer address\n            const HEAP32 = this.fAllocator.getInt32Array();\n            HEAP32[(buffers >> 2) + chan] = buffer;\n        }\n        //this.displayMemory(\"Allocated soundfile buffers\");\n        return buffers;\n    }\n\n    shareBuffers(curChan: number, maxChan: number) {\n        // Share the same buffers for all other channels so that we have maxChan channels available\n        const HEAP32 = this.fAllocator.getInt32Array();\n        for (let chan = curChan; chan < maxChan; chan++) {\n            HEAP32[(this.fBuffers >> 2) + chan] =\n                HEAP32[(this.fBuffers >> 2) + (chan % curChan)];\n        }\n    }\n\n    copyToOut(\n        part: number,\n        maxChannels: number,\n        offset: number,\n        audioData: AudioData\n    ) {\n        // Set the soundfile fields in wasm memory\n        if (this.fIntSize === 4) {\n            const HEAP32 = this.fAllocator.getInt32Array();\n            HEAP32[(this.fLength >> Math.log2(this.fIntSize)) + part] =\n                audioData.audioBuffer[0].length;\n            HEAP32[(this.fSR >> Math.log2(this.fIntSize)) + part] =\n                audioData.sampleRate;\n            HEAP32[(this.fOffset >> Math.log2(this.fIntSize)) + part] = offset;\n        } else {\n            const HEAP64 = this.fAllocator.getInt64Array();\n            HEAP64[(this.fLength >> Math.log2(this.fIntSize)) + part] = BigInt(\n                audioData.audioBuffer[0].length\n            );\n            HEAP64[(this.fSR >> Math.log2(this.fIntSize)) + part] = BigInt(\n                audioData.sampleRate\n            );\n            HEAP64[(this.fOffset >> Math.log2(this.fIntSize)) + part] =\n                BigInt(offset);\n        }\n\n        console.log(\n            `copyToOut: part: ${part}, maxChannels: ${maxChannels}, offset: ${offset}, buffer: ${audioData}`\n        );\n\n        //this.displayMemory(\"IN copyToOut, BEFORE copyToOutReal\", true);\n        // Copy the soundfile data to the buffer\n        if (this.fSampleSize === 8) {\n            this.copyToOutReal64(maxChannels, offset, audioData);\n        } else {\n            this.copyToOutReal32(maxChannels, offset, audioData);\n        }\n        //this.displayMemory(\"IN copyToOut, AFTER copyToOutReal\");\n    }\n\n    copyToOutReal32(maxChannels: number, offset: number, audioData: AudioData) {\n        const HEAP32 = this.fAllocator.getInt32Array();\n        const HEAPF = this.fAllocator.getFloat32Array();\n        for (let chan = 0; chan < audioData.audioBuffer.length; chan++) {\n            const input: Float32Array = audioData.audioBuffer[chan];\n            const output: number = HEAP32[(this.fBuffers >> 2) + chan];\n            const begin: number =\n                (output + offset * this.fSampleSize) >>\n                Math.log2(this.fSampleSize);\n            const end: number =\n                (output + (offset + input.length) * this.fSampleSize) >>\n                Math.log2(this.fSampleSize);\n            console.log(\n                `copyToOutReal32 begin: ${begin}, end: ${end}, delta: ${end - begin}`\n            );\n            const outputReal: Float32Array = HEAPF.subarray(\n                (output + offset * this.fSampleSize) >>\n                    Math.log2(this.fSampleSize),\n                (output + (offset + input.length) * this.fSampleSize) >>\n                    Math.log2(this.fSampleSize)\n            );\n            for (let sample = 0; sample < input.length; sample++) {\n                outputReal[sample] = input[sample];\n            }\n        }\n    }\n\n    copyToOutReal64(maxChannels: number, offset: number, audioData: AudioData) {\n        const HEAP32 = this.fAllocator.getInt32Array();\n        const HEAPF = this.fAllocator.getFloat64Array();\n        for (let chan = 0; chan < audioData.audioBuffer.length; chan++) {\n            const input: Float32Array = audioData.audioBuffer[chan];\n            const output: number = HEAP32[(this.fBuffers >> 2) + chan];\n            const begin: number =\n                (output + offset * this.fSampleSize) >>\n                Math.log2(this.fSampleSize);\n            const end: number =\n                (output + (offset + input.length) * this.fSampleSize) >>\n                Math.log2(this.fSampleSize);\n            console.log(\n                `copyToOutReal64 begin: ${begin}, end: ${end}, delta: ${end - begin}`\n            );\n            const outputReal: Float64Array = HEAPF.subarray(\n                (output + offset * this.fSampleSize) >>\n                    Math.log2(this.fSampleSize),\n                (output + (offset + input.length) * this.fSampleSize) >>\n                    Math.log2(this.fSampleSize)\n            );\n            for (let sample = 0; sample < input.length; sample++) {\n                outputReal[sample] = input[sample];\n            }\n        }\n    }\n\n    emptyFile(part: number, offset: number): number {\n        // Set the soundfile fields in wasm memory\n        if (this.fIntSize === 4) {\n            const HEAP32 = this.fAllocator.getInt32Array();\n            HEAP32[(this.fLength >> Math.log2(this.fIntSize)) + part] =\n                Soundfile.BUFFER_SIZE;\n            HEAP32[(this.fSR >> Math.log2(this.fIntSize)) + part] =\n                Soundfile.SAMPLE_RATE;\n            HEAP32[(this.fOffset >> Math.log2(this.fIntSize)) + part] = offset;\n        } else {\n            const HEAP64 = this.fAllocator.getInt64Array();\n            HEAP64[(this.fLength >> Math.log2(this.fIntSize)) + part] = BigInt(\n                Soundfile.BUFFER_SIZE\n            );\n            HEAP64[(this.fSR >> Math.log2(this.fIntSize)) + part] = BigInt(\n                Soundfile.SAMPLE_RATE\n            );\n            HEAP64[(this.fOffset >> Math.log2(this.fIntSize)) + part] =\n                BigInt(offset);\n        }\n\n        // Update and return the new offset\n        return offset + Soundfile.BUFFER_SIZE;\n    }\n\n    displayMemory(where: string = '', mem: boolean = false) {\n        console.log('Soundfile memory: ' + where);\n        console.log(`fPtr: ${this.fPtr}`);\n        console.log(`fBuffers: ${this.fBuffers}`);\n        console.log(`fLength: ${this.fLength}`);\n        console.log(`fSR: ${this.fSR}`);\n        console.log(`fOffset: ${this.fOffset}`);\n        const HEAP32 = this.fAllocator.getInt32Array();\n        if (mem) console.log(`HEAP32: ${HEAP32}`);\n        console.log(`HEAP32[this.fPtr >> 2]: ${HEAP32[this.fPtr >> 2]}`);\n        console.log(\n            `HEAP32[(this.fPtr + ptrSize) >> 2]: ${HEAP32[(this.fPtr + this.fPtrSize) >> 2]}`\n        );\n        console.log(\n            `HEAP32[(this.fPtr + 2 * ptrSize) >> 2]: ${HEAP32[(this.fPtr + 2 * this.fPtrSize) >> 2]}`\n        );\n        console.log(\n            `HEAP32[(this.fPtr + 3 * ptrSize) >> 2]: ${HEAP32[(this.fPtr + 3 * this.fPtrSize) >> 2]}`\n        );\n    }\n\n    // Return the pointer to the soundfile structure in wasm memory\n    getPtr(): number {\n        return this.fPtr;\n    }\n\n    getHEAP32(): Int32Array {\n        return this.fAllocator.getInt32Array();\n    }\n    getHEAPFloat32(): Float32Array {\n        return this.fAllocator.getFloat32Array();\n    }\n\n    getHEAPFloat64(): Float64Array {\n        return this.fAllocator.getFloat64Array();\n    }\n}\n\n/**\n * DSP implementation that mimic the C++ 'dsp' class:\n * - adding MIDI control: metadata are decoded and incoming MIDI messages will control the associated controllers\n * - an output handler can be set to treat produced output controllers (like 'bargraph')\n * - an input handler can be set to follow control parameter changes (like sliders)\n * - regular controllers are handled using setParamValue/getParamValue and getParams methods\n */\nexport interface IFaustBaseWebAudioDsp {\n    /**\n     * Set the parameter output handler, to  be called in the 'compute' method with output parameters (like bargraph).\n     *\n     * @param handler - the output handler\n     */\n    setOutputParamHandler(handler: OutputParamHandler | null): void;\n\n    /**\n     * Get the parameter output handler.\n     *\n     * @return the current output handler\n     */\n    getOutputParamHandler(): OutputParamHandler | null;\n\n    /**\n     * Call the output parameter handler with a path and value.\n     *\n     * @param path - the path to the wanted parameter (retrieved using 'getParams' method)\n     * @param value - the float value for the wanted control\n     */\n    callOutputParamHandler(path: string, value: number): void;\n\n    /**\n     * Set the parameter input handler, to be called when input parameters change (like sliders).\n     *\n     * @param handler - the input handler\n     */\n    setInputParamHandler(handler: InputParamHandler | null): void;\n\n    /**\n     * Get the parameter input handler.\n     *\n     * @return the current input handler\n     */\n    getInputParamHandler(): InputParamHandler | null;\n\n    /**\n     * Call the input parameter handler with a path and value.\n     *\n     * @param path - the path to the wanted parameter (retrieved using 'getParams' method)\n     * @param value - the float value for the wanted control\n     */\n    callInputParamHandler(path: string, value: number): void;\n\n    /**\n     * Set the compute handler, to  be called in the 'compute' method with buffer size.\n     *\n     * @param handler - the compute handler\n     */\n    setComputeHandler(handler: ComputeHandler | null): void;\n\n    /**\n     * Get the compute handler.\n     *\n     * @return the current output handler\n     */\n    getComputeHandler(): ComputeHandler | null;\n\n    /**\n     * Set the plot handler, to  be called in the 'compute' method with various info (see PlotHandler type).\n     *\n     * @param handler - the plot handler\n     */\n    setPlotHandler(handler: PlotHandler | null): void;\n\n    /**\n     * Get the plot handler.\n     *\n     * @return the current plot handler\n     */\n    getPlotHandler(): PlotHandler | null;\n\n    /**\n     * Return instance number of audio inputs.\n     *\n     * @return the instance number of audio inputs\n     */\n    getNumInputs(): number;\n\n    /**\n     * Return instance number of audio outputs.\n     *\n     * @return the instance number of audio outputs\n     */\n    getNumOutputs(): number;\n\n    /**\n     * DSP instance computation, to be called with successive input/output audio buffers, using their size.\n     *\n     * @param inputs - the input audio buffers\n     * @param outputs - the output audio buffers\n     */\n    compute(inputs: Float32Array[], outputs: Float32Array[]): boolean;\n\n    /**\n     * Give a handler to be called on 'declare key value' kind of metadata.\n     *\n     * @param handler - the handler to be used\n     */\n    metadata(handler: MetadataHandler): void;\n\n    /**\n     * Handle untyped MIDI messages.\n     *\n     * @param data - and arry of MIDI bytes\n     */\n    midiMessage(data: number[] | Uint8Array): void;\n\n    /**\n     * Handle MIDI ctrlChange messages.\n     *\n     * @param channel - the MIDI channel (0..15, not used for now)\n     * @param ctrl - the MIDI controller number (0..127)\n     * @param value - the MIDI controller value (0..127)\n     */\n    ctrlChange(chan: number, ctrl: number, value: number): void;\n\n    /**\n     * Handle MIDI pitchWheel messages.\n     *\n     * @param channel - the MIDI channel (0..15, not used for now)\n     * @param value - the MIDI controller value (0..16383)\n     */\n    pitchWheel(chan: number, value: number): void;\n\n    /**\n     * Handle MIDI keyOn messages.\n     * @param channel\n     * @param pitch\n     * @param velocity\n     */\n    keyOn(channel: number, pitch: number, velocity: number): void;\n\n    /**\n     * Handle MIDI keyOn messages.\n     * @param channel\n     * @param pitch\n     * @param velocity\n     */\n    keyOff(channel: number, pitch: number, velocity: number): void;\n\n    /**\n     * Set parameter value.\n     *\n     * @param path - the path to the wanted parameter (retrieved using 'getParams' method)\n     * @param val - the float value for the wanted control\n     */\n    setParamValue(path: string, value: number): void;\n\n    /**\n     * Get parameter value.\n     *\n     * @param path - the path to the wanted parameter (retrieved using 'getParams' method)\n     *\n     * @return the float value\n     */\n    getParamValue(path: string): number;\n\n    /**\n     * Get the table of all input parameters paths.\n     *\n     * @return the table of all input parameters paths\n     */\n    getParams(): string[];\n\n    /**\n     * Get DSP JSON description with its UI and metadata as object.\n     *\n     * @return the DSP JSON description as object\n     */\n    getMeta(): FaustDspMeta;\n\n    /**\n     * Get DSP UI description.\n     *\n     * @return the DSP UI description\n     */\n    getUI(): FaustUIDescriptor;\n\n    /**\n     * Get DSP UI items description.\n     *\n     * @return the DSP UI items description\n     */\n    getDescriptors(): FaustUIInputItem[];\n\n    /**\n     * Get DSP JSON description with its UI and metadata.\n     *\n     * @return the DSP JSON description\n     */\n    getJSON(): string;\n\n    /**\n     * Start accelerometer and gyroscope handlers.\n     */\n    startSensors(): void;\n\n    /**\n     * Stop accelerometer and gyroscope handlers.\n     */\n    stopSensors(): void;\n\n    /** Indicating if the DSP handles the accelerometer */\n    readonly hasAccInput: boolean;\n\n    /**\n     * Accelerometer handling.\n     * accelerationIncludingGravity: DeviceMotionEvent[\"accelerationIncludingGravity\"]\n     * invert: boolean\n     */\n    propagateAcc(\n        accelerationIncludingGravity: NonNullable<\n            DeviceMotionEvent['accelerationIncludingGravity']\n        >,\n        invert: boolean\n    ): void;\n\n    /** Indicating if the DSP handles the gyroscope */\n    readonly hasGyrInput: boolean;\n\n    /**\n     * Gyroscope handling.\n     * event: Pick<DeviceOrientationEvent, \"alpha\" | \"beta\" | \"gamma\">\n     */\n    propagateGyr(\n        event: Pick<DeviceOrientationEvent, 'alpha' | 'beta' | 'gamma'>\n    ): void;\n\n    /**\n     * Start the DSP audio processing.\n     */\n    start(): void;\n\n    /**\n     * Stop the DSP audio processing.\n     */\n    stop(): void;\n\n    /**\n     * Destroy the DSP.\n     */\n    destroy(): void;\n}\n\nexport type IFaustMonoWebAudioDsp = IFaustBaseWebAudioDsp;\nexport interface IFaustMonoWebAudioNode\n    extends IFaustMonoWebAudioDsp,\n        AudioNode {}\n\nexport interface IFaustPolyWebAudioDsp extends IFaustBaseWebAudioDsp {\n    /**\n     * Handle MIDI keyOn messages.\n     *\n     * @param channel - the MIDI channel (0..15, not used for now)\n     * @param pitch - the MIDI pitch value (0..127)\n     * @param velocity - the MIDI velocity value (0..127)\n     */\n    keyOn(channel: number, pitch: number, velocity: number): void;\n\n    /**\n     * Handle MIDI keyOff messages.\n     *\n     * @param channel - the MIDI channel (0..15, not used for now)\n     * @param pitch - the MIDI pitch value (0..127)\n     * @param velocity - the MIDI velocity value (0..127)\n     */\n    keyOff(channel: number, pitch: number, velocity: number): void;\n\n    /**\n     * Stop all playing notes.\n     *\n     * @param hard - whether to immediately stop notes or put them in release mode\n     */\n    allNotesOff(hard: boolean): void;\n}\nexport interface IFaustPolyWebAudioNode\n    extends IFaustPolyWebAudioDsp,\n        AudioNode {}\n\nexport class FaustBaseWebAudioDsp implements IFaustBaseWebAudioDsp {\n    protected fOutputHandler: OutputParamHandler | null = null;\n    protected fInputHandler: InputParamHandler | null = null;\n    protected fComputeHandler: ComputeHandler | null = null;\n\n    // To handle MIDI events plot\n    protected fPlotHandler: PlotHandler | null = null;\n    protected fCachedEvents: { type: string; data: any }[] = [];\n    protected fBufferNum = 0;\n\n    protected fInChannels: Float32Array[] | Float64Array[] = [];\n    protected fOutChannels: Float32Array[] | Float64Array[] = [];\n\n    protected fOutputsTimer = 5;\n\n    // UI items path\n    protected fInputsItems: string[] = [];\n    protected fOutputsItems: string[] = [];\n    protected fDescriptor: FaustUIInputItem[] = [];\n\n    // Soundfile handling\n    protected fSoundfiles: SoundfileItem[] = [];\n    protected fSoundfileBuffers: LooseFaustDspFactory['soundfiles'] = {};\n    /** Keep the end of memory offset before soundfiles */\n    protected fEndMemory: number;\n\n    // Accelerometer handling\n    protected fAcc: SensorEventHandlers; // array of accelerometer handlers on x,y,y axes, to be called with DeviceMotionEvent\n    protected fGyr: SensorEventHandlers; // array of gyroscope handlers on alpha,beta,gama axes, to be called with DeviceMotionEvent\n\n    // Buffers in wasm memory\n    protected fAudioInputs!: number;\n    protected fAudioOutputs!: number;\n\n    protected fBufferSize: number;\n    protected fPtrSize: number;\n    protected fSampleSize: number;\n\n    // MIDI handling\n    protected fPitchwheelLabel: {\n        path: string;\n        chan: number;\n        min: number;\n        max: number;\n    }[] = [];\n    protected fCtrlLabel: {\n        path: string;\n        chan: number;\n        min: number;\n        max: number;\n    }[][] = new Array(128).fill(null).map(() => []);\n    // array of MIDI key handlers; array index is the MIDI note number\n    protected fMidiKeyLabel: {\n        path: string;\n        chan: number;\n        min: number;\n        max: number;\n    }[][] = new Array(128).fill(null).map(() => []);\n    protected fMidiKeyOnLabel: {\n        path: string;\n        chan: number;\n        min: number;\n        max: number;\n    }[][] = new Array(128).fill(null).map(() => []);\n    protected fMidiKeyOffLabel: {\n        path: string;\n        chan: number;\n        min: number;\n        max: number;\n    }[][] = new Array(128).fill(null).map(() => []);\n\n    protected fPathTable: { [address: string]: number } = {};\n    protected fUICallback: UIHandler = (item: FaustUIItem) => {\n        if (item.type === 'hbargraph' || item.type === 'vbargraph') {\n            const registerPath = (alias: string) => {\n                if (this.fPathTable[alias] === undefined) {\n                    this.fPathTable[alias] = item.index;\n                }\n            };\n            // Keep bargraph adresses\n            this.fOutputsItems.push(item.address);\n            registerPath(item.address);\n            registerPath(item.shortname);\n            registerPath(item.label);\n        } else if (\n            item.type === 'vslider' ||\n            item.type === 'hslider' ||\n            item.type === 'button' ||\n            item.type === 'checkbox' ||\n            item.type === 'nentry'\n        ) {\n            const registerPath = (alias: string) => {\n                if (this.fPathTable[alias] === undefined) {\n                    this.fPathTable[alias] = item.index;\n                }\n            };\n            // Keep inputs adresses\n            this.fInputsItems.push(item.address);\n            registerPath(item.address);\n            registerPath(item.shortname);\n            registerPath(item.label);\n            this.fDescriptor.push(item);\n            if (!item.meta) return;\n            item.meta.forEach((meta) => {\n                const { midi, acc, gyr } = meta;\n                // Parse 'midi' metadata\n                if (midi) {\n                    const strMidi = midi.trim();\n                    if (strMidi === 'pitchwheel') {\n                        const matched = strMidi.match(/^pitchwheel\\s(\\d+)/);\n                        // \"pitchwheel chan\"\n                        if (matched) {\n                            this.fPitchwheelLabel.push({\n                                path: item.address,\n                                chan: parseInt(matched[1]),\n                                min: item.min as number,\n                                max: item.max as number\n                            });\n                            // \"pitchwheel\"\n                        } else {\n                            this.fPitchwheelLabel.push({\n                                path: item.address,\n                                chan: 0,\n                                min: item.min as number,\n                                max: item.max as number\n                            });\n                        }\n                    } else {\n                        // \"ctrl num chan\"\n                        const matched2 = strMidi.match(/^ctrl\\s(\\d+)\\s(\\d+)/);\n                        // \"ctrl num\"\n                        const matched1 = strMidi.match(/^ctrl\\s(\\d+)/);\n                        // match `key <note>[ <channel>]`\n                        const matchedKey = strMidi.match(\n                            /^key\\s+(\\d+)(?:\\s+(\\d+))?$/\n                        );\n                        //match `keyon <note>[ <channel>]`\n                        const matchedKeyOn = strMidi.match(\n                            /^keyon\\s+(\\d+)(?:\\s+(\\d+))?$/\n                        );\n                        //match `keyoff <note>[ <channel>]`\n                        const matchedKeyOff = strMidi.match(\n                            /^keyoff\\s+(\\d+)(?:\\s+(\\d+))?$/\n                        );\n                        if (matched2) {\n                            this.fCtrlLabel[parseInt(matched2[1])].push({\n                                path: item.address,\n                                chan: parseInt(matched2[2]),\n                                min: item.min as number,\n                                max: item.max as number\n                            });\n                        } else if (matched1) {\n                            this.fCtrlLabel[parseInt(matched1[1])].push({\n                                path: item.address,\n                                chan: 0,\n                                min: item.min as number,\n                                max: item.max as number\n                            });\n                        } else if (matchedKey) {\n                            const note = parseInt(matchedKey[1]);\n                            const channel = matchedKey[2]\n                                ? parseInt(matchedKey[2])\n                                : 0;\n                            this.fMidiKeyLabel[note].push({\n                                path: item.address,\n                                chan: channel,\n                                min: (item.min as number) ?? 0,\n                                max: (item.max as number) ?? 1\n                            });\n                        } else if (matchedKeyOn) {\n                            const note = parseInt(matchedKeyOn[1]);\n                            const channel = matchedKeyOn[2]\n                                ? parseInt(matchedKeyOn[2])\n                                : 0;\n                            this.fMidiKeyOnLabel[note].push({\n                                path: item.address,\n                                chan: channel,\n                                min: (item.min as number) ?? 0,\n                                max: (item.max as number) ?? 1\n                            });\n                        } else if (matchedKeyOff) {\n                            const note = parseInt(matchedKeyOff[1]);\n                            const channel = matchedKeyOff[2]\n                                ? parseInt(matchedKeyOff[2])\n                                : 0;\n                            this.fMidiKeyOffLabel[note].push({\n                                path: item.address,\n                                chan: channel,\n                                min: (item.min as number) ?? 0,\n                                max: (item.max as number) ?? 1\n                            });\n                        }\n                    }\n                }\n\n                // Parse 'acc' metadata\n                if (acc) {\n                    const numAcc: number[] = acc.trim().split(' ').map(Number);\n                    this.setupAccHandler(\n                        item.address,\n                        FaustSensors.convertToAxis(numAcc[0]),\n                        FaustSensors.convertToCurve(numAcc[1]),\n                        numAcc[2],\n                        numAcc[3],\n                        numAcc[4],\n                        item.min as number,\n                        item.init as number,\n                        item.max as number\n                    );\n                }\n                // Parse 'gyr' metadata\n                if (gyr) {\n                    const numAcc: number[] = gyr.trim().split(' ').map(Number);\n                    this.setupGyrHandler(\n                        item.address,\n                        FaustSensors.convertToAxis(numAcc[0]),\n                        FaustSensors.convertToCurve(numAcc[1]),\n                        numAcc[2],\n                        numAcc[3],\n                        numAcc[4],\n                        item.min as number,\n                        item.init as number,\n                        item.max as number\n                    );\n                }\n            });\n        } else if (item.type === 'soundfile') {\n            this.fSoundfiles.push({\n                name: item.label,\n                url: item.url,\n                index: item.index,\n                basePtr: -1\n            });\n        }\n    };\n\n    // Audio callback\n    protected fProcessing = false;\n    protected fDestroyed = false;\n    protected fFirstCall = true;\n\n    protected fJSONDsp!: FaustDspMeta;\n\n    constructor(\n        sampleSize: number,\n        bufferSize: number,\n        soundfiles: LooseFaustDspFactory['soundfiles']\n    ) {\n        this.fBufferSize = bufferSize;\n        this.fPtrSize = sampleSize; // Done on wast/wasm backend side\n        this.fSampleSize = sampleSize;\n        this.fSoundfileBuffers = soundfiles;\n        this.fAcc = { x: [], y: [], z: [] };\n        this.fGyr = { x: [], y: [], z: [] };\n    }\n\n    // Tools\n    static remap(\n        v: number,\n        mn0: number,\n        mx0: number,\n        mn1: number,\n        mx1: number\n    ) {\n        return ((v - mn0) / (mx0 - mn0)) * (mx1 - mn1) + mn1;\n    }\n\n    // JSON parsing functions\n    static parseUI(\n        ui: FaustUIDescriptor,\n        callback: (item: FaustUIItem) => any\n    ) {\n        ui.forEach((group) => this.parseGroup(group, callback));\n    }\n\n    static parseGroup(\n        group: FaustUIGroup,\n        callback: (item: FaustUIItem) => any\n    ) {\n        if (group.items) {\n            this.parseItems(group.items, callback);\n        }\n    }\n    static parseItems(\n        items: FaustUIItem[],\n        callback: (item: FaustUIItem) => any\n    ) {\n        items.forEach((item) => this.parseItem(item, callback));\n    }\n\n    static parseItem(item: FaustUIItem, callback: (item: FaustUIItem) => any) {\n        if (\n            item.type === 'vgroup' ||\n            item.type === 'hgroup' ||\n            item.type === 'tgroup'\n        ) {\n            this.parseItems(item.items, callback);\n        } else {\n            callback(item);\n        }\n    }\n\n    /** Split the soundfile names and return an array of names */\n    static splitSoundfileNames(input: string): string[] {\n        // Trim off the curly braces at the start and end, if present\n        const trimmed = input.replace(/^\\{|\\}$/g, '');\n        // Split the string into an array of strings and remove first and last characters\n        return trimmed\n            .split(';')\n            .map((str) =>\n                str.length <= 2 ? '' : str.substring(1, str.length - 1)\n            );\n    }\n\n    get hasAccInput() {\n        return this.fAcc.x.length + this.fAcc.y.length + this.fAcc.z.length > 0;\n    }\n    propagateAcc(\n        accelerationIncludingGravity: NonNullable<\n            DeviceMotionEvent['accelerationIncludingGravity']\n        >,\n        invert: boolean = false\n    ) {\n        // Get accelerometervalues\n        const { x, y, z } = accelerationIncludingGravity;\n\n        if (invert) {\n            // Call the accelerometer handlers\n            if (x !== null) this.fAcc.x.forEach((handler) => handler(-x));\n            if (y !== null) this.fAcc.y.forEach((handler) => handler(-y));\n            if (z !== null) this.fAcc.z.forEach((handler) => handler(-z));\n        } else {\n            // Call the accelerometer handlers\n            if (x !== null) this.fAcc.x.forEach((handler) => handler(x));\n            if (y !== null) this.fAcc.y.forEach((handler) => handler(y));\n            if (z !== null) this.fAcc.z.forEach((handler) => handler(z));\n        }\n    }\n\n    get hasGyrInput() {\n        return this.fGyr.x.length + this.fGyr.y.length + this.fGyr.z.length > 0;\n    }\n    propagateGyr(\n        event: Pick<DeviceOrientationEvent, 'alpha' | 'beta' | 'gamma'>\n    ) {\n        // Get gyroscope values\n        const { alpha, beta, gamma } = event;\n\n        // Call the gyroscope handlers\n        if (alpha !== null) this.fGyr.x.forEach((handler) => handler(alpha));\n        if (beta !== null) this.fGyr.y.forEach((handler) => handler(beta));\n        if (gamma !== null) this.fGyr.z.forEach((handler) => handler(gamma));\n    }\n\n    /** Build the accelerometer handler */\n    private setupAccHandler(\n        path: string,\n        axis: Axis,\n        curve: Curve,\n        amin: number,\n        amid: number,\n        amax: number,\n        min: number,\n        init: number,\n        max: number\n    ) {\n        const handler: UpdatableValueConverter = FaustSensors.buildHandler(\n            curve,\n            amin,\n            amid,\n            amax,\n            min,\n            init,\n            max\n        );\n        switch (axis) {\n            case Axis.x:\n                this.fAcc.x.push((val) =>\n                    this.setParamValue(path, handler.uiToFaust(val))\n                );\n                break;\n            case Axis.y:\n                this.fAcc.y.push((val) =>\n                    this.setParamValue(path, handler.uiToFaust(val))\n                );\n                break;\n            case Axis.z:\n                this.fAcc.z.push((val) =>\n                    this.setParamValue(path, handler.uiToFaust(val))\n                );\n                break;\n        }\n    }\n\n    /** Build the gyroscope handler */\n    private setupGyrHandler(\n        path: string,\n        axis: Axis,\n        curve: Curve,\n        amin: number,\n        amid: number,\n        amax: number,\n        min: number,\n        init: number,\n        max: number\n    ) {\n        const handler: UpdatableValueConverter = FaustSensors.buildHandler(\n            curve,\n            amin,\n            amid,\n            amax,\n            min,\n            init,\n            max\n        );\n        switch (axis) {\n            case Axis.x:\n                this.fGyr.x.push((val) =>\n                    this.setParamValue(path, handler.uiToFaust(val))\n                );\n                break;\n            case Axis.y:\n                this.fGyr.y.push((val) =>\n                    this.setParamValue(path, handler.uiToFaust(val))\n                );\n                break;\n            case Axis.z:\n                this.fGyr.z.push((val) =>\n                    this.setParamValue(path, handler.uiToFaust(val))\n                );\n                break;\n        }\n    }\n\n    static extractUrlsFromMeta(dspMeta: FaustDspMeta): string[] {\n        // Find the entry with the \"soundfiles\" key\n        const soundfilesEntry = dspMeta.meta.find(\n            (entry) => entry.soundfiles !== undefined\n        );\n        // If the entry is found, split the string by semicolon to get the URLs\n        if (soundfilesEntry) {\n            return soundfilesEntry.soundfiles\n                .split(';')\n                .filter((url) => url !== '');\n        } else {\n            return [];\n        }\n    }\n\n    /**\n     * Load a soundfile possibly containing several parts in the DSP struct.\n     * Soundfile pointers are located at 'index' offset, to be read in the JSON file.\n     * The DSP struct is located at baseDSP in the wasm memory,\n     * either a monophonic DSP, or a voice in a polyphonic context.\n     *\n     * @param allocator : the wasm memory allocator\n     * @param baseDSP : the base DSP in the wasm memory\n     * @param name : the name of the soundfile\n     * @param url : the url of the soundfile\n     */\n    private loadSoundfile(\n        allocator: WasmAllocator,\n        baseDSP: number,\n        name: string,\n        url: string\n    ) {\n        console.log(`Soundfile ${name} paths: ${url}`);\n        const soundfileIds = FaustBaseWebAudioDsp.splitSoundfileNames(url);\n        const item = this.fSoundfiles.find((item) => item.url === url);\n        if (!item) throw new Error(`Soundfile with ${url} cannot be found !}`);\n        // Use the cached Soundfile\n        if (item.basePtr !== -1) {\n            // Update HEAP32 after soundfile creation\n            const HEAP32 = allocator.getInt32Array();\n            // Fill the soundfile structure in wasm memory, soundfiles are at the beginning of the DSP memory\n            console.log(\n                `Soundfile CACHE ${url}} : ${name} loaded at ${item.basePtr} in wasm memory with index ${item.index}`\n            );\n            // Soundfile is located at 'index' in the DSP struct, to be added with baseDSP in the wasm memory\n            HEAP32[(baseDSP + item.index) >> 2] = item.basePtr;\n        } else {\n            // Create the soundfiles\n            const soundfile = this.createSoundfile(\n                allocator,\n                soundfileIds,\n                this.fSoundfileBuffers\n            );\n            if (soundfile) {\n                // Update HEAP32 after soundfile creation\n                const HEAP32 = soundfile.getHEAP32();\n                // Get the soundfile pointer in wasm memory\n                item.basePtr = soundfile.getPtr();\n                console.log(\n                    `Soundfile ${name} loaded at ${item.basePtr} in wasm memory with index ${item.index}`\n                );\n                // Soundfile is located at 'index' in the DSP struct, to be added with baseDSP in the wasm memory\n                HEAP32[(baseDSP + item.index) >> 2] = item.basePtr;\n            } else {\n                console.log(\n                    `Soundfile ${name} for ${url} cannot be created !}`\n                );\n            }\n        }\n    }\n\n    createSoundfile(\n        allocator: WasmAllocator,\n        soundfileIdList: string[],\n        soundfiles: LooseFaustDspFactory['soundfiles'],\n        maxChan = Soundfile.MAX_CHAN\n    ) {\n        let curChan = 1; // At least one channel\n        let totalLength = 0;\n\n        // Compute total length and channels max of all files\n        for (const soundfileId of soundfileIdList) {\n            let chan = 0;\n            let len = 0;\n            const audioData = soundfiles?.[soundfileId];\n            if (audioData) {\n                chan = audioData.audioBuffer.length;\n                len = audioData.audioBuffer[0].length;\n            } else {\n                len = Soundfile.BUFFER_SIZE;\n                chan = 1;\n            }\n            curChan = Math.max(curChan, chan);\n            totalLength += len;\n        }\n\n        // Complete with empty parts\n        totalLength +=\n            (Soundfile.MAX_SOUNDFILE_PARTS - soundfileIdList.length) *\n            Soundfile.BUFFER_SIZE;\n\n        // Create the soundfile\n        const soundfile = new Soundfile(\n            allocator,\n            this.fSampleSize,\n            curChan,\n            totalLength,\n            maxChan,\n            soundfileIdList.length\n        );\n\n        //soundfile.displayMemory(\"After soundfile creation\");\n        // Init offset\n        let offset = 0;\n\n        // Read all files\n        for (let part = 0; part < soundfileIdList.length; part++) {\n            const soundfileId = soundfileIdList[part];\n            const audioData = soundfiles?.[soundfileId];\n            if (audioData) {\n                //soundfile.displayMemory(\"BEFORE copyToOut\");\n                soundfile.copyToOut(part, maxChan, offset, audioData);\n                //soundfile.displayMemory(\"AFTER copyToOut\");\n                offset += audioData.audioBuffer[0].length;\n            } else {\n                // Empty sound\n                offset = soundfile.emptyFile(part, offset);\n            }\n        }\n\n        //soundfile.displayMemory(\"After reading soundfiles\");\n\n        // Complete with empty parts\n        for (\n            let part = soundfileIdList.length;\n            part < Soundfile.MAX_SOUNDFILE_PARTS;\n            part++\n        ) {\n            offset = soundfile.emptyFile(part, offset);\n        }\n\n        //soundfile.displayMemory(\"After emptyFile\");\n\n        // Share the same buffers for all other channels so that we have maxChan channels available\n        soundfile.shareBuffers(curChan, maxChan);\n\n        //soundfile.displayMemory(\"After shareBuffers\");\n\n        return soundfile;\n    }\n    /**\n     * Init soundfiles memory.\n     *\n     * @param allocator : the wasm memory allocator\n     * @param baseDSP : the DSP struct (either a monophonic DSP of polyphonic voice) base DSP in the wasm memory\n     */\n    protected initSoundfileMemory(allocator: WasmAllocator, baseDSP: number) {\n        // Create and fill the soundfile structure\n        for (const { name, url } of this.fSoundfiles) {\n            this.loadSoundfile(allocator, baseDSP, name, url);\n        }\n    }\n\n    protected updateOutputs() {\n        if (\n            this.fOutputsItems.length > 0 &&\n            this.fOutputHandler &&\n            this.fOutputsTimer-- === 0\n        ) {\n            this.fOutputsTimer = 5;\n            this.fOutputsItems.forEach((item) =>\n                this.fOutputHandler?.(item, this.getParamValue(item))\n            );\n        }\n    }\n\n    // Public API\n    metadata(handler: MetadataHandler) {\n        if (this.fJSONDsp.meta) {\n            this.fJSONDsp.meta.forEach((meta) =>\n                handler(Object.keys(meta)[0], meta[Object.keys(meta)[0]])\n            );\n        }\n    }\n\n    compute(input: Float32Array[], output: Float32Array[]) {\n        return false;\n    }\n\n    setOutputParamHandler(handler: OutputParamHandler | null) {\n        this.fOutputHandler = handler;\n    }\n    getOutputParamHandler() {\n        return this.fOutputHandler;\n    }\n    callOutputParamHandler(path: string, value: number) {\n        if (this.fOutputHandler) {\n            this.fOutputHandler(path, value);\n        }\n    }\n\n    setInputParamHandler(handler: InputParamHandler | null) {\n        this.fInputHandler = handler;\n    }\n    getInputParamHandler() {\n        return this.fInputHandler;\n    }\n    callInputParamHandler(path: string, value: number) {\n        if (this.fInputHandler) {\n            this.fInputHandler(path, value);\n        }\n    }\n\n    setComputeHandler(handler: ComputeHandler | null) {\n        this.fComputeHandler = handler;\n    }\n    getComputeHandler() {\n        return this.fComputeHandler;\n    }\n\n    setPlotHandler(handler: PlotHandler | null) {\n        this.fPlotHandler = handler;\n    }\n    getPlotHandler() {\n        return this.fPlotHandler;\n    }\n\n    getNumInputs() {\n        return -1;\n    }\n    getNumOutputs() {\n        return -1;\n    }\n\n    midiMessage(data: number[] | Uint8Array) {\n        if (this.fPlotHandler) this.fCachedEvents.push({ data, type: 'midi' });\n        const cmd = data[0] >> 4;\n        const channel = data[0] & 0xf;\n        const data1 = data[1];\n        const data2 = data[2];\n        if (cmd === 11) return this.ctrlChange(channel, data1, data2);\n        if (cmd === 14) return this.pitchWheel(channel, data2 * 128.0 + data1);\n        if (cmd === 9) {\n            if (data2 > 0) return this.keyOn(channel, data1, data2);\n            else return this.keyOff(channel, data1, data2);\n        }\n        if (cmd === 8) {\n            return this.keyOff(channel, data1, data2);\n        }\n    }\n\n    ctrlChange(channel: number, ctrl: number, value: number) {\n        if (this.fPlotHandler)\n            this.fCachedEvents.push({\n                type: 'ctrlChange',\n                data: [channel, ctrl, value]\n            });\n        if (this.fCtrlLabel[ctrl].length) {\n            this.fCtrlLabel[ctrl].forEach((ctrl) => {\n                const { path, chan } = ctrl;\n                if (chan === 0 || channel === chan - 1) {\n                    this.setParamValue(\n                        path,\n                        FaustBaseWebAudioDsp.remap(\n                            value,\n                            0,\n                            127,\n                            ctrl.min,\n                            ctrl.max\n                        )\n                    );\n                    // Typically used to reflect parameter change on GUI\n                    if (this.fOutputHandler)\n                        this.fOutputHandler(path, this.getParamValue(path));\n                }\n            });\n        }\n    }\n\n    keyOn(channel: number, pitch: number, velocity: number) {\n        if (this.fPlotHandler)\n            this.fCachedEvents.push({\n                type: 'keyOn',\n                data: [channel, pitch, velocity]\n            });\n        this.fMidiKeyOnLabel[pitch].forEach((key) => {\n            const { path, chan } = key;\n            if (chan === 0 || channel === chan - 1) {\n                this.setParamValue(\n                    path,\n                    FaustBaseWebAudioDsp.remap(\n                        velocity,\n                        0,\n                        127,\n                        key.min,\n                        key.max\n                    )\n                );\n                // Typically used to reflect parameter change on GUI\n                if (this.fOutputHandler)\n                    this.fOutputHandler(path, this.getParamValue(path));\n            }\n        });\n        this.fMidiKeyLabel[pitch].forEach((key) => {\n            const { path, chan } = key;\n            if (chan === 0 || channel === chan - 1) {\n                this.setParamValue(\n                    path,\n                    FaustBaseWebAudioDsp.remap(\n                        velocity,\n                        0,\n                        127,\n                        key.min,\n                        key.max\n                    )\n                );\n                // Typically used to reflect parameter change on GUI\n                if (this.fOutputHandler)\n                    this.fOutputHandler(path, this.getParamValue(path));\n            }\n        });\n    }\n\n    keyOff(channel: number, pitch: number, velocity: number) {\n        if (this.fPlotHandler)\n            this.fCachedEvents.push({\n                type: 'keyOff',\n                data: [channel, pitch, velocity]\n            });\n        this.fMidiKeyOffLabel[pitch].forEach((key) => {\n            const { path, chan } = key;\n            if (chan === 0 || channel === chan - 1) {\n                this.setParamValue(\n                    path,\n                    FaustBaseWebAudioDsp.remap(\n                        velocity,\n                        0,\n                        127,\n                        key.min,\n                        key.max\n                    )\n                );\n                // Typically used to reflect parameter change on GUI\n                if (this.fOutputHandler)\n                    this.fOutputHandler(path, this.getParamValue(path));\n            }\n        });\n        this.fMidiKeyLabel[pitch].forEach((key) => {\n            const { path, chan } = key;\n            if (chan === 0 || channel === chan - 1) {\n                this.setParamValue(path, 0);\n                // Typically used to reflect parameter change on GUI\n                if (this.fOutputHandler)\n                    this.fOutputHandler(path, this.getParamValue(path));\n            }\n        });\n    }\n\n    pitchWheel(channel: number, wheel: number) {\n        if (this.fPlotHandler)\n            this.fCachedEvents.push({\n                type: 'pitchWheel',\n                data: [channel, wheel]\n            });\n        this.fPitchwheelLabel.forEach((pw) => {\n            const { path, chan } = pw;\n            if (chan === 0 || channel === chan - 1) {\n                this.setParamValue(\n                    path,\n                    FaustBaseWebAudioDsp.remap(wheel, 0, 16383, pw.min, pw.max)\n                );\n                // Typically used to reflect parameter change on GUI\n                if (this.fOutputHandler)\n                    this.fOutputHandler(path, this.getParamValue(path));\n            }\n        });\n    }\n\n    setParamValue(path: string, value: number) {}\n    getParamValue(path: string) {\n        return 0;\n    }\n\n    getParams() {\n        return this.fInputsItems;\n    }\n    getMeta() {\n        return this.fJSONDsp;\n    }\n    getJSON() {\n        return JSON.stringify(this.getMeta());\n    }\n    getUI() {\n        return this.fJSONDsp.ui;\n    }\n    getDescriptors() {\n        return this.fDescriptor;\n    }\n\n    hasSoundfiles() {\n        return this.fSoundfiles.length > 0;\n    }\n\n    startSensors(): void {\n        this.startSensors();\n    }\n\n    stopSensors(): void {\n        this.stopSensors();\n    }\n\n    start() {\n        this.fProcessing = true;\n    }\n\n    stop() {\n        this.fProcessing = false;\n    }\n\n    destroy() {\n        this.fDestroyed = true;\n        this.fOutputHandler = null;\n        this.fInputHandler = null;\n        this.fComputeHandler = null;\n        this.fPlotHandler = null;\n    }\n}\n\nexport class FaustMonoWebAudioDsp\n    extends FaustBaseWebAudioDsp\n    implements IFaustMonoWebAudioDsp\n{\n    private fInstance: FaustMonoDspInstance;\n    private fDSP!: number;\n\n    constructor(\n        instance: FaustMonoDspInstance,\n        sampleRate: number,\n        sampleSize: number,\n        bufferSize: number,\n        soundfiles: LooseFaustDspFactory['soundfiles']\n    ) {\n        super(sampleSize, bufferSize, soundfiles);\n        this.fInstance = instance;\n\n        console.log(`sampleSize: ${sampleSize} bufferSize: ${bufferSize}`);\n\n        // Create JSON object\n        this.fJSONDsp = JSON.parse(this.fInstance.json);\n\n        // Setup GUI\n        FaustBaseWebAudioDsp.parseUI(this.fJSONDsp.ui, this.fUICallback);\n\n        // Setup wasm memory\n        this.fEndMemory = this.initMemory();\n\n        // Init DSP\n        this.fInstance.api.init(this.fDSP, sampleRate);\n\n        // Init soundfiles memory is needed\n        if (this.fSoundfiles.length > 0) {\n            // Create memory allocator for soundfiles in wasm memory, starting at the end of DSP memory\n            const allocator = new WasmAllocator(\n                this.fInstance.memory,\n                this.fEndMemory\n            );\n\n            // Init soundfiles memory\n            this.initSoundfileMemory(allocator, this.fDSP);\n        }\n    }\n\n    private initMemory(): number {\n        // Start of DSP memory: Mono DSP is placed first with index 0\n        this.fDSP = 0;\n\n        // Audio buffer start at the end of DSP\n        const $audio = this.fJSONDsp.size;\n\n        // Setup audio pointers offset\n        this.fAudioInputs = $audio;\n        this.fAudioOutputs =\n            this.fAudioInputs + this.getNumInputs() * this.fPtrSize;\n\n        // Prepare wasm memory layout\n        const $audioInputs =\n            this.fAudioOutputs + this.getNumOutputs() * this.fPtrSize;\n        const $audioOutputs =\n            $audioInputs +\n            this.getNumInputs() * this.fBufferSize * this.fSampleSize;\n        // Compute memory end in bytes\n        const endMemory =\n            $audioOutputs +\n            this.getNumOutputs() * this.fBufferSize * this.fSampleSize;\n\n        // Setup Int32 and Real views of the memory\n        const HEAP = this.fInstance.memory.buffer;\n        const HEAP32 = new Int32Array(HEAP);\n        const HEAPF =\n            this.fSampleSize === 4\n                ? new Float32Array(HEAP)\n                : new Float64Array(HEAP);\n\n        if (this.getNumInputs() > 0) {\n            for (let chan = 0; chan < this.getNumInputs(); chan++) {\n                HEAP32[(this.fAudioInputs >> 2) + chan] =\n                    $audioInputs + this.fBufferSize * this.fSampleSize * chan;\n            }\n            // Prepare Ins buffer tables\n            const dspInChans = HEAP32.subarray(\n                this.fAudioInputs >> 2,\n                (this.fAudioInputs + this.getNumInputs() * this.fPtrSize) >> 2\n            );\n            for (let chan = 0; chan < this.getNumInputs(); chan++) {\n                this.fInChannels[chan] = HEAPF.subarray(\n                    dspInChans[chan] >> Math.log2(this.fSampleSize),\n                    (dspInChans[chan] + this.fBufferSize * this.fSampleSize) >>\n                        Math.log2(this.fSampleSize)\n                );\n            }\n        }\n        if (this.getNumOutputs() > 0) {\n            for (let chan = 0; chan < this.getNumOutputs(); chan++) {\n                HEAP32[(this.fAudioOutputs >> 2) + chan] =\n                    $audioOutputs + this.fBufferSize * this.fSampleSize * chan;\n            }\n            // Prepare Out buffer tables\n            const dspOutChans = HEAP32.subarray(\n                this.fAudioOutputs >> 2,\n                (this.fAudioOutputs + this.getNumOutputs() * this.fPtrSize) >> 2\n            );\n            for (let chan = 0; chan < this.getNumOutputs(); chan++) {\n                this.fOutChannels[chan] = HEAPF.subarray(\n                    dspOutChans[chan] >> Math.log2(this.fSampleSize),\n                    (dspOutChans[chan] + this.fBufferSize * this.fSampleSize) >>\n                        Math.log2(this.fSampleSize)\n                );\n            }\n        }\n\n        return endMemory;\n    }\n\n    toString() {\n        return `============== Mono Memory layout ==============\n        this.fBufferSize: ${this.fBufferSize}\n        this.fJSONDsp.size: ${this.fJSONDsp.size}\n        this.fAudioInputs: ${this.fAudioInputs}\n        this.fAudioOutputs: ${this.fAudioOutputs}\n        this.fDSP: ${this.fDSP}`;\n    }\n\n    // Public API\n    compute(\n        input:\n            | Float32Array[]\n            | ((input: Float32Array[] | Float64Array[]) => any),\n        output:\n            | Float32Array[]\n            | ((output: Float32Array[] | Float64Array[]) => any)\n    ) {\n        // Check DSP state\n        if (this.fDestroyed) return false;\n\n        // Check Processing state: the node returns 'true' to stay in the graph, even if not processing\n        if (!this.fProcessing) return true;\n\n        // Init memory again on first call (since WebAssembly.memory.grow() may have been called)\n        if (this.fFirstCall) {\n            this.initMemory();\n            this.fFirstCall = false;\n        }\n\n        if (typeof input === 'function') {\n            // Call input callback to avoid array copy\n            input(this.fInChannels);\n        } else {\n            // Check inputs\n            if (\n                this.getNumInputs() > 0 &&\n                (!input || !input[0] || input[0].length === 0)\n            ) {\n                // console.log(\"Process input error\");\n                return true;\n            }\n\n            // Check outputs\n            if (\n                this.getNumOutputs() > 0 &&\n                typeof output !== 'function' &&\n                (!output || !output[0] || output[0].length === 0)\n            ) {\n                // console.log(\"Process output error\");\n                return true;\n            }\n\n            // Copy inputs\n            if (input !== undefined) {\n                for (\n                    let chan = 0;\n                    chan < Math.min(this.getNumInputs(), input.length);\n                    chan++\n                ) {\n                    const dspInput = this.fInChannels[chan];\n                    dspInput.set(input[chan]);\n                }\n            }\n        }\n        // Possibly call an externally given callback (for instance to synchronize playing a MIDIFile...)\n        if (this.fComputeHandler) this.fComputeHandler(this.fBufferSize);\n\n        // Compute\n        this.fInstance.api.compute(\n            this.fDSP,\n            this.fBufferSize,\n            this.fAudioInputs,\n            this.fAudioOutputs\n        );\n\n        // Update bargraph\n        this.updateOutputs();\n\n        let forPlot = this.fOutChannels;\n        if (typeof output === 'function') {\n            // Call output callback to avoid array copy\n            output(this.fOutChannels);\n        } else {\n            // Copy outputs\n            for (\n                let chan = 0;\n                chan < Math.min(this.getNumOutputs(), output.length);\n                chan++\n            ) {\n                const dspOutput = this.fOutChannels[chan];\n                output[chan].set(dspOutput);\n                // console.log(\"chan: \" + chan + \" output: \" + dspOutput[0]);\n            }\n            forPlot = output;\n        }\n\n        // PlotHandler handling\n        if (this.fPlotHandler) {\n            this.fPlotHandler(\n                forPlot,\n                this.fBufferNum++,\n                this.fCachedEvents.length ? this.fCachedEvents : undefined\n            );\n            this.fCachedEvents = [];\n        }\n\n        return true;\n    }\n\n    metadata(handler: MetadataHandler) {\n        super.metadata(handler);\n    }\n\n    getNumInputs() {\n        return this.fInstance.api.getNumInputs(this.fDSP);\n    }\n    getNumOutputs() {\n        return this.fInstance.api.getNumOutputs(this.fDSP);\n    }\n\n    setParamValue(path: string, value: number) {\n        if (this.fPlotHandler)\n            this.fCachedEvents.push({ type: 'param', data: { path, value } });\n        this.fInstance.api.setParamValue(\n            this.fDSP,\n            this.fPathTable[path],\n            value\n        );\n        this.callInputParamHandler(path, this.getParamValue(path));\n    }\n    getParamValue(path: string) {\n        return this.fInstance.api.getParamValue(\n            this.fDSP,\n            this.fPathTable[path]\n        );\n    }\n\n    getMeta() {\n        return this.fJSONDsp;\n    }\n    getJSON() {\n        return this.fInstance.json;\n    }\n    getDescriptors() {\n        return this.fDescriptor;\n    }\n    getUI() {\n        return this.fJSONDsp.ui;\n    }\n}\n\nexport class FaustWebAudioDspVoice {\n    // Voice state\n    static get kActiveVoice() {\n        return 0;\n    }\n    static get kFreeVoice() {\n        return -1;\n    }\n    static get kReleaseVoice() {\n        return -2;\n    }\n    static get kLegatoVoice() {\n        return -3;\n    }\n    static get kNoVoice() {\n        return -4;\n    }\n    static get VOICE_STOP_LEVEL() {\n        return 0.00003162;\n    } // -90 db\n\n    private fFreqLabel: number[] = [];\n    private fGateLabel: number[] = [];\n    private fGainLabel: number[] = [];\n    private fKeyLabel: number[] = [];\n    private fVelLabel: number[] = [];\n    private fDSP: number; // Voice DSP location in wasm memory\n    private fAPI: IFaustDspInstance; // Voice DSP code\n    // Accessed by PolyDSPImp class\n    fCurNote = FaustWebAudioDspVoice.kFreeVoice;\n    fNextNote = -1;\n    fNextVel = -1;\n    fDate = 0;\n    fLevel = 0;\n\n    constructor(\n        $dsp: number,\n        api: IFaustDspInstance,\n        inputItems: string[],\n        pathTable: { [address: string]: number },\n        sampleRate: number\n    ) {\n        this.fDSP = $dsp;\n        this.fAPI = api;\n        this.fAPI.init(this.fDSP, sampleRate);\n        this.extractPaths(inputItems, pathTable);\n    }\n\n    static midiToFreq(note: number) {\n        return 440.0 * 2 ** ((note - 69) / 12);\n    }\n\n    static normalizeVelocity(velocity: number) {\n        return velocity / 127.0;\n    }\n\n    private extractPaths(\n        inputItems: string[],\n        pathTable: { [address: string]: number }\n    ) {\n        inputItems.forEach((item) => {\n            if (item.endsWith('/gate')) {\n                this.fGateLabel.push(pathTable[item]);\n            } else if (item.endsWith('/freq')) {\n                this.fFreqLabel.push(pathTable[item]);\n            } else if (item.endsWith('/key')) {\n                this.fKeyLabel.push(pathTable[item]);\n            } else if (item.endsWith('/gain')) {\n                this.fGainLabel.push(pathTable[item]);\n            } else if (item.endsWith('/vel') && item.endsWith('/velocity')) {\n                this.fVelLabel.push(pathTable[item]);\n            }\n        });\n    }\n\n    // Public API\n    keyOn(pitch: number, velocity: number, legato: boolean = false) {\n        if (legato) {\n            this.fNextNote = pitch;\n            this.fNextVel = velocity;\n        } else {\n            this.fFreqLabel.forEach((index) =>\n                this.fAPI.setParamValue(\n                    this.fDSP,\n                    index,\n                    FaustWebAudioDspVoice.midiToFreq(pitch)\n                )\n            );\n            this.fGateLabel.forEach((index) =>\n                this.fAPI.setParamValue(this.fDSP, index, 1)\n            );\n            this.fGainLabel.forEach((index) =>\n                this.fAPI.setParamValue(\n                    this.fDSP,\n                    index,\n                    FaustWebAudioDspVoice.normalizeVelocity(velocity)\n                )\n            );\n            this.fKeyLabel.forEach((index) =>\n                this.fAPI.setParamValue(this.fDSP, index, pitch)\n            );\n            this.fVelLabel.forEach((index) =>\n                this.fAPI.setParamValue(this.fDSP, index, velocity)\n            );\n            // Keep pitch\n            this.fCurNote = pitch;\n        }\n    }\n\n    keyOff(hard: boolean = false) {\n        this.fGateLabel.forEach((index) =>\n            this.fAPI.setParamValue(this.fDSP, index, 0)\n        );\n        if (hard) {\n            this.fCurNote = FaustWebAudioDspVoice.kFreeVoice;\n        } else {\n            this.fCurNote = FaustWebAudioDspVoice.kReleaseVoice;\n        }\n    }\n\n    computeLegato(\n        bufferSize: number,\n        $inputs: number,\n        $outputZero: number,\n        $outputsHalf: number\n    ) {\n        const size = bufferSize / 2;\n\n        // Reset envelops\n        this.fGateLabel.forEach((index) =>\n            this.fAPI.setParamValue(this.fDSP, index, 0)\n        );\n\n        // Compute current voice on half buffer\n        this.fAPI.compute(this.fDSP, size, $inputs, $outputZero);\n\n        // Start next keyOn\n        this.keyOn(this.fNextNote, this.fNextVel);\n\n        // Compute on second half buffer\n        this.fAPI.compute(this.fDSP, size, $inputs, $outputsHalf);\n    }\n\n    compute(bufferSize: number, $inputs: number, $outputs: number) {\n        this.fAPI.compute(this.fDSP, bufferSize, $inputs, $outputs);\n    }\n\n    setParamValue(index: number, value: number) {\n        this.fAPI.setParamValue(this.fDSP, index, value);\n    }\n    getParamValue(index: number) {\n        return this.fAPI.getParamValue(this.fDSP, index);\n    }\n}\n\nexport class FaustPolyWebAudioDsp\n    extends FaustBaseWebAudioDsp\n    implements IFaustPolyWebAudioDsp\n{\n    private fInstance: FaustPolyDspInstance;\n    private fEffect!: number;\n    private fJSONEffect: FaustDspMeta | null;\n    private fAudioMixing!: number;\n    private fAudioMixingHalf!: number;\n    private fVoiceTable: FaustWebAudioDspVoice[];\n\n    constructor(\n        instance: FaustPolyDspInstance,\n        sampleRate: number,\n        sampleSize: number,\n        bufferSize: number,\n        soundfiles: LooseFaustDspFactory['soundfiles']\n    ) {\n        super(sampleSize, bufferSize, soundfiles);\n        this.fInstance = instance;\n\n        console.log(`sampleSize: ${sampleSize} bufferSize: ${bufferSize}`);\n\n        // Create JSON for voice\n        this.fJSONDsp = JSON.parse(this.fInstance.voiceJSON);\n\n        // Create JSON for effect\n        this.fJSONEffect =\n            this.fInstance.effectAPI && this.fInstance.effectJSON\n                ? JSON.parse(this.fInstance.effectJSON)\n                : null;\n\n        // Setup GUI\n        FaustBaseWebAudioDsp.parseUI(this.fJSONDsp.ui, this.fUICallback);\n        if (this.fJSONEffect)\n            FaustBaseWebAudioDsp.parseUI(this.fJSONEffect.ui, this.fUICallback);\n\n        // Setup wasm memory\n        this.fEndMemory = this.initMemory();\n\n        // Init DSP voices\n        this.fVoiceTable = [];\n        for (let voice = 0; voice < this.fInstance.voices; voice++) {\n            this.fVoiceTable.push(\n                new FaustWebAudioDspVoice(\n                    this.fJSONDsp.size * voice,\n                    this.fInstance.voiceAPI,\n                    this.fInputsItems,\n                    this.fPathTable,\n                    sampleRate\n                )\n            );\n        }\n\n        // Init effect\n        if (this.fInstance.effectAPI)\n            this.fInstance.effectAPI.init(this.fEffect, sampleRate);\n\n        // Init soundfiles memory is needed\n        if (this.fSoundfiles.length > 0) {\n            // Create memory allocator for soundfiles in wasm memory, starting at the end of DSP memory\n            const allocator = new WasmAllocator(\n                this.fInstance.memory,\n                this.fEndMemory\n            );\n            // Init soundfiles memory for all voices\n            for (let voice = 0; voice < this.fInstance.voices; voice++) {\n                this.initSoundfileMemory(allocator, this.fJSONDsp.size * voice);\n            }\n        }\n    }\n\n    private initMemory() {\n        // Effet start at the end of all DSP voices\n        this.fEffect = this.fJSONDsp.size * this.fInstance.voices;\n\n        // Audio buffer start at the end of effect\n        const $audio =\n            this.fEffect + (this.fJSONEffect ? this.fJSONEffect.size : 0);\n\n        // Setup audio pointers offset\n        this.fAudioInputs = $audio;\n        this.fAudioOutputs =\n            this.fAudioInputs + this.getNumInputs() * this.fPtrSize;\n        this.fAudioMixing =\n            this.fAudioOutputs + this.getNumOutputs() * this.fPtrSize;\n        this.fAudioMixingHalf =\n            this.fAudioMixing + this.getNumOutputs() * this.fPtrSize;\n\n        // Prepare wasm memory layout\n        const $audioInputs =\n            this.fAudioMixingHalf + this.getNumOutputs() * this.fPtrSize;\n        const $audioOutputs =\n            $audioInputs +\n            this.getNumInputs() * this.fBufferSize * this.fSampleSize;\n        const $audioMixing =\n            $audioOutputs +\n            this.getNumOutputs() * this.fBufferSize * this.fSampleSize;\n\n        // Compute memory end in bytes\n        const endMemory =\n            $audioMixing +\n            this.getNumOutputs() * this.fBufferSize * this.fSampleSize;\n\n        // Setup Int32 and Real views of the memory\n        const HEAP = this.fInstance.memory.buffer;\n        const HEAP32 = new Int32Array(HEAP);\n        const HEAPF =\n            this.fSampleSize === 4\n                ? new Float32Array(HEAP)\n                : new Float64Array(HEAP);\n\n        if (this.getNumInputs() > 0) {\n            for (let chan = 0; chan < this.getNumInputs(); chan++) {\n                HEAP32[(this.fAudioInputs >> 2) + chan] =\n                    $audioInputs + this.fBufferSize * this.fSampleSize * chan;\n            }\n            // Prepare Ins buffer tables\n            const dspInChans = HEAP32.subarray(\n                this.fAudioInputs >> 2,\n                (this.fAudioInputs + this.getNumInputs() * this.fPtrSize) >> 2\n            );\n            for (let chan = 0; chan < this.getNumInputs(); chan++) {\n                this.fInChannels[chan] = HEAPF.subarray(\n                    dspInChans[chan] >> Math.log2(this.fSampleSize),\n                    (dspInChans[chan] + this.fBufferSize * this.fSampleSize) >>\n                        Math.log2(this.fSampleSize)\n                );\n            }\n        }\n        if (this.getNumOutputs() > 0) {\n            for (let chan = 0; chan < this.getNumOutputs(); chan++) {\n                HEAP32[(this.fAudioOutputs >> 2) + chan] =\n                    $audioOutputs + this.fBufferSize * this.fSampleSize * chan;\n                HEAP32[(this.fAudioMixing >> 2) + chan] =\n                    $audioMixing + this.fBufferSize * this.fSampleSize * chan;\n                HEAP32[(this.fAudioMixingHalf >> 2) + chan] =\n                    $audioMixing +\n                    this.fBufferSize * this.fSampleSize * chan +\n                    (this.fBufferSize / 2) * this.fSampleSize;\n            }\n            // Prepare Out buffer tables\n            const dspOutChans = HEAP32.subarray(\n                this.fAudioOutputs >> 2,\n                (this.fAudioOutputs + this.getNumOutputs() * this.fPtrSize) >> 2\n            );\n            for (let chan = 0; chan < this.getNumOutputs(); chan++) {\n                this.fOutChannels[chan] = HEAPF.subarray(\n                    dspOutChans[chan] >> Math.log2(this.fSampleSize),\n                    (dspOutChans[chan] + this.fBufferSize * this.fSampleSize) >>\n                        Math.log2(this.fSampleSize)\n                );\n            }\n        }\n\n        return endMemory;\n    }\n\n    toString() {\n        return `============== Poly Memory layout ==============\n        this.fBufferSize: ${this.fBufferSize}\n        this.fJSONDsp.size: ${this.fJSONDsp.size}\n        this.fAudioInputs: ${this.fAudioInputs}\n        this.fAudioOutputs: ${this.fAudioOutputs}\n        this.fAudioMixing: ${this.fAudioMixing}\n        this.fAudioMixingHalf: ${this.fAudioMixingHalf}`;\n    }\n\n    private allocVoice(voice: number, type: number) {\n        this.fVoiceTable[voice].fDate++;\n        this.fVoiceTable[voice].fCurNote = type;\n        return voice;\n    }\n\n    private getPlayingVoice(pitch: number) {\n        let voicePlaying = FaustWebAudioDspVoice.kNoVoice;\n        let oldestDatePlaying = Number.MAX_VALUE;\n\n        for (let i = 0; i < this.fInstance.voices; i++) {\n            const curNote = this.fVoiceTable[i].fCurNote;\n            const nextNote = this.fVoiceTable[i].fNextNote;\n\n            if (\n                curNote === pitch ||\n                (curNote === FaustWebAudioDspVoice.kLegatoVoice &&\n                    nextNote === pitch)\n            ) {\n                // Keeps oldest playing voice\n                if (this.fVoiceTable[i].fDate < oldestDatePlaying) {\n                    oldestDatePlaying = this.fVoiceTable[i].fDate;\n                    voicePlaying = i;\n                }\n            }\n        }\n        return voicePlaying;\n    }\n\n    private getFreeVoice() {\n        for (let voice = 0; voice < this.fInstance.voices; voice++) {\n            if (\n                this.fVoiceTable[voice].fCurNote ===\n                FaustWebAudioDspVoice.kFreeVoice\n            ) {\n                return this.allocVoice(\n                    voice,\n                    FaustWebAudioDspVoice.kActiveVoice\n                );\n            }\n        }\n\n        let voiceRelease = FaustWebAudioDspVoice.kNoVoice;\n        let voicePlaying = FaustWebAudioDspVoice.kNoVoice;\n        let oldestDateRelease = Number.MAX_VALUE;\n        let oldestDatePlaying = Number.MAX_VALUE;\n\n        for (let voice = 0; voice < this.fInstance.voices; voice++) {\n            // Scan all voices\n            // Try to steal a voice in DspVoice.kReleaseVoice mode...\n            if (\n                this.fVoiceTable[voice].fCurNote ===\n                FaustWebAudioDspVoice.kReleaseVoice\n            ) {\n                // Keeps oldest release voice\n                if (this.fVoiceTable[voice].fDate < oldestDateRelease) {\n                    oldestDateRelease = this.fVoiceTable[voice].fDate;\n                    voiceRelease = voice;\n                }\n            } else if (this.fVoiceTable[voice].fDate < oldestDatePlaying) {\n                oldestDatePlaying = this.fVoiceTable[voice].fDate;\n                voicePlaying = voice;\n            }\n        }\n        // Then decide which one to steal\n        if (oldestDateRelease !== Number.MAX_VALUE) {\n            console.log(\n                `Steal release voice : voice_date = ${this.fVoiceTable[voiceRelease].fDate} voice = ${voiceRelease}`\n            );\n            return this.allocVoice(\n                voiceRelease,\n                FaustWebAudioDspVoice.kLegatoVoice\n            );\n        }\n        if (oldestDatePlaying !== Number.MAX_VALUE) {\n            console.log(\n                `Steal playing voice : voice_date = ${this.fVoiceTable[voicePlaying].fDate} voice = ${voicePlaying}`\n            );\n            return this.allocVoice(\n                voicePlaying,\n                FaustWebAudioDspVoice.kLegatoVoice\n            );\n        }\n        return FaustWebAudioDspVoice.kNoVoice;\n    }\n\n    // Public API\n    compute(input: Float32Array[], output: Float32Array[]) {\n        // Check DSP state\n        if (this.fDestroyed) return false;\n\n        // Init memory again on first call (since WebAssembly.memory.grow() may have been called)\n        if (this.fFirstCall) {\n            this.initMemory();\n            this.fFirstCall = false;\n        }\n\n        // Check Processing state: the node returns 'true' to stay in the graph, even if not processing\n        if (!this.fProcessing) return true;\n\n        // Check inputs\n        if (\n            this.getNumInputs() > 0 &&\n            (!input || !input[0] || input[0].length === 0)\n        ) {\n            // console.log(\"Process input error\");\n            return true;\n        }\n\n        // Check outputs\n        if (\n            this.getNumOutputs() > 0 &&\n            (!output || !output[0] || output[0].length === 0)\n        ) {\n            // console.log(\"Process output error\");\n            return true;\n        }\n\n        // Copy inputs\n        if (input !== undefined) {\n            for (\n                let chan = 0;\n                chan < Math.min(this.getNumInputs(), input.length);\n                ++chan\n            ) {\n                const dspInput = this.fInChannels[chan];\n                dspInput.set(input[chan]);\n            }\n        }\n\n        // Possibly call an externally given callback (for instance to synchronize playing a MIDIFile...)\n        if (this.fComputeHandler) this.fComputeHandler(this.fBufferSize);\n\n        // Compute\n        this.fInstance.mixerAPI.clearOutput(\n            this.fBufferSize,\n            this.getNumOutputs(),\n            this.fAudioOutputs\n        );\n        this.fVoiceTable.forEach((voice) => {\n            if (voice.fCurNote === FaustWebAudioDspVoice.kLegatoVoice) {\n                // Play from current note and next note\n                voice.computeLegato(\n                    this.fBufferSize,\n                    this.fAudioInputs,\n                    this.fAudioMixing,\n                    this.fAudioMixingHalf\n                );\n                // FadeOut on first half buffer\n                this.fInstance.mixerAPI.fadeOut(\n                    this.fBufferSize / 2,\n                    this.getNumOutputs(),\n                    this.fAudioMixing\n                );\n                // Mix it in result\n                voice.fLevel = this.fInstance.mixerAPI.mixCheckVoice(\n                    this.fBufferSize,\n                    this.getNumOutputs(),\n                    this.fAudioMixing,\n                    this.fAudioOutputs\n                );\n            } else if (voice.fCurNote !== FaustWebAudioDspVoice.kFreeVoice) {\n                // Compute current note\n                voice.compute(\n                    this.fBufferSize,\n                    this.fAudioInputs,\n                    this.fAudioMixing\n                );\n                // Mix it in result\n                voice.fLevel = this.fInstance.mixerAPI.mixCheckVoice(\n                    this.fBufferSize,\n                    this.getNumOutputs(),\n                    this.fAudioMixing,\n                    this.fAudioOutputs\n                );\n                // Check the level to possibly set the voice in kFreeVoice again\n                if (\n                    voice.fCurNote == FaustWebAudioDspVoice.kReleaseVoice &&\n                    voice.fLevel < FaustWebAudioDspVoice.VOICE_STOP_LEVEL\n                ) {\n                    voice.fCurNote = FaustWebAudioDspVoice.kFreeVoice;\n                }\n            }\n        });\n        if (this.fInstance.effectAPI)\n            this.fInstance.effectAPI.compute(\n                this.fEffect,\n                this.fBufferSize,\n                this.fAudioOutputs,\n                this.fAudioOutputs\n            );\n\n        // Update bargraph\n        this.updateOutputs();\n\n        if (output !== undefined) {\n            // Copy outputs\n            for (\n                let chan = 0;\n                chan < Math.min(this.getNumOutputs(), output.length);\n                chan++\n            ) {\n                const dspOutput = this.fOutChannels[chan];\n                output[chan].set(dspOutput);\n            }\n\n            // PlotHandler handling\n            if (this.fPlotHandler) {\n                this.fPlotHandler(\n                    output,\n                    this.fBufferNum++,\n                    this.fCachedEvents.length ? this.fCachedEvents : undefined\n                );\n                this.fCachedEvents = [];\n            }\n        }\n\n        return true;\n    }\n\n    getNumInputs() {\n        return this.fInstance.voiceAPI.getNumInputs(0);\n    }\n    getNumOutputs() {\n        return this.fInstance.voiceAPI.getNumOutputs(0);\n    }\n\n    private static findPath(o: any, p: string) {\n        if (typeof o !== 'object') {\n            return false;\n        } else if (o.address) {\n            return o.address === p;\n        } else {\n            for (const k in o) {\n                if (FaustPolyWebAudioDsp.findPath(o[k], p)) return true;\n            }\n            return false;\n        }\n    }\n\n    setParamValue(path: string, value: number) {\n        if (this.fPlotHandler)\n            this.fCachedEvents.push({ type: 'param', data: { path, value } });\n        if (\n            this.fJSONEffect &&\n            FaustPolyWebAudioDsp.findPath(this.fJSONEffect.ui, path) &&\n            this.fInstance.effectAPI\n        ) {\n            this.fInstance.effectAPI.setParamValue(\n                this.fEffect,\n                this.fPathTable[path],\n                value\n            );\n        } else {\n            this.fVoiceTable.forEach((voice) =>\n                voice.setParamValue(this.fPathTable[path], value)\n            );\n        }\n        this.callInputParamHandler(path, this.getParamValue(path));\n    }\n    getParamValue(path: string) {\n        if (\n            this.fJSONEffect &&\n            FaustPolyWebAudioDsp.findPath(this.fJSONEffect.ui, path) &&\n            this.fInstance.effectAPI\n        ) {\n            return this.fInstance.effectAPI.getParamValue(\n                this.fEffect,\n                this.fPathTable[path]\n            );\n        } else {\n            return this.fVoiceTable[0].getParamValue(this.fPathTable[path]);\n        }\n    }\n\n    getMeta() {\n        const o = this.fJSONDsp;\n        const e = this.fJSONEffect;\n        const r = { ...o };\n        if (e) {\n            r.ui = [\n                {\n                    type: 'tgroup',\n                    label: 'Sequencer',\n                    items: [\n                        { type: 'vgroup', label: 'Instrument', items: o.ui },\n                        { type: 'vgroup', label: 'Effect', items: e.ui }\n                    ]\n                }\n            ];\n        } else {\n            r.ui = [\n                {\n                    type: 'tgroup',\n                    label: 'Polyphonic',\n                    items: [{ type: 'vgroup', label: 'Voices', items: o.ui }]\n                }\n            ];\n        }\n        return r as FaustDspMeta;\n    }\n\n    getJSON() {\n        return JSON.stringify(this.getMeta());\n    }\n\n    getUI() {\n        return this.getMeta().ui;\n    }\n\n    getDescriptors() {\n        return this.fDescriptor;\n    }\n\n    midiMessage(data: number[] | Uint8Array) {\n        const cmd = data[0] >> 4;\n        const channel = data[0] & 0xf;\n        const data1 = data[1];\n        const data2 = data[2];\n        if (cmd === 8 || (cmd === 9 && data2 === 0))\n            return this.keyOff(channel, data1, data2);\n        else if (cmd === 9) return this.keyOn(channel, data1, data2);\n        else super.midiMessage(data);\n    }\n\n    ctrlChange(channel: number, ctrl: number, value: number) {\n        if (ctrl === 123 || ctrl === 120) {\n            this.allNotesOff(true);\n        } else {\n            super.ctrlChange(channel, ctrl, value);\n        }\n    }\n\n    keyOn(channel: number, pitch: number, velocity: number) {\n        if (this.fPlotHandler)\n            this.fCachedEvents.push({\n                type: 'keyOn',\n                data: [channel, pitch, velocity]\n            });\n        const voice = this.getFreeVoice();\n        this.fVoiceTable[voice].keyOn(\n            pitch,\n            velocity,\n            this.fVoiceTable[voice].fCurNote ==\n                FaustWebAudioDspVoice.kLegatoVoice\n        );\n    }\n\n    keyOff(channel: number, pitch: number, velocity: number) {\n        if (this.fPlotHandler)\n            this.fCachedEvents.push({\n                type: 'keyOff',\n                data: [channel, pitch, velocity]\n            });\n        const voice = this.getPlayingVoice(pitch);\n        if (voice !== FaustWebAudioDspVoice.kNoVoice) {\n            this.fVoiceTable[voice].keyOff();\n        } else {\n            console.log('Playing pitch = %d not found\\n', pitch);\n        }\n    }\n\n    allNotesOff(hard: boolean = true) {\n        this.fCachedEvents.push({ type: 'ctrlChange', data: [0, 123, 0] });\n        this.fVoiceTable.forEach((voice) => voice.keyOff(hard));\n    }\n}\n", "import {\n    ComputeHandler,\n    FaustBaseWebAudioDsp,\n    FaustMonoWebAudioDsp,\n    FaustPolyWebAudioDsp,\n    IFaustBaseWebAudioDsp,\n    IFaustMonoWebAudioDsp,\n    IFaustPolyWebAudioDsp,\n    InputParamHandler,\n    MetadataHandler,\n    OutputParamHandler,\n    PlotHandler\n} from './FaustWebAudioDsp';\nimport { AudioParamDescriptor, FaustUIItem } from './types';\n\n/**\n *  For offline rendering.\n */\nexport interface IFaustOfflineProcessor extends IFaustBaseWebAudioDsp {\n    render(\n        inputs?: Float32Array[],\n        length?: number,\n        onUpdate?: (sample: number) => any\n    ): Float32Array[];\n}\n\nexport interface IFaustMonoOfflineProcessor\n    extends IFaustOfflineProcessor,\n        IFaustMonoWebAudioDsp {}\nexport interface IFaustPolyOfflineProcessor\n    extends IFaustOfflineProcessor,\n        IFaustPolyWebAudioDsp {}\n\nexport class FaustOfflineProcessor<Poly extends boolean = false> {\n    protected fDSPCode!: Poly extends true\n        ? FaustPolyWebAudioDsp\n        : FaustMonoWebAudioDsp;\n\n    protected fBufferSize: number;\n    protected fInputs: Float32Array[];\n    protected fOutputs: Float32Array[];\n\n    constructor(\n        instance: Poly extends true\n            ? FaustPolyWebAudioDsp\n            : FaustMonoWebAudioDsp,\n        bufferSize: number\n    ) {\n        this.fDSPCode = instance;\n        this.fBufferSize = bufferSize;\n        this.fInputs = new Array(this.fDSPCode.getNumInputs())\n            .fill(null)\n            .map(() => new Float32Array(bufferSize));\n        this.fOutputs = new Array(this.fDSPCode.getNumOutputs())\n            .fill(null)\n            .map(() => new Float32Array(bufferSize));\n    }\n\n    // Public API\n\n    getParameterDescriptors() {\n        const params = [] as AudioParamDescriptor[];\n        // Analyse voice JSON to generate AudioParam parameters\n        const callback = (item: FaustUIItem) => {\n            let param: AudioParamDescriptor | null = null;\n            const polyKeywords = [\n                '/gate',\n                '/freq',\n                '/gain',\n                '/key',\n                '/vel',\n                '/velocity'\n            ];\n            const isPolyReserved =\n                'address' in item &&\n                !!polyKeywords.find((k) => item.address.endsWith(k));\n            if (\n                this.fDSPCode instanceof FaustMonoWebAudioDsp ||\n                !isPolyReserved\n            ) {\n                if (\n                    item.type === 'vslider' ||\n                    item.type === 'hslider' ||\n                    item.type === 'nentry'\n                ) {\n                    param = {\n                        name: item.address,\n                        defaultValue: item.init || 0,\n                        minValue: item.min || 0,\n                        maxValue: item.max || 0\n                    };\n                } else if (item.type === 'button' || item.type === 'checkbox') {\n                    param = {\n                        name: item.address,\n                        defaultValue: item.init || 0,\n                        minValue: 0,\n                        maxValue: 1\n                    };\n                }\n            }\n            if (param) params.push(param);\n        };\n        FaustBaseWebAudioDsp.parseUI(this.fDSPCode.getUI(), callback);\n        return params;\n    }\n    compute(input: Float32Array[], output: Float32Array[]) {\n        return this.fDSPCode.compute(input, output);\n    }\n\n    setOutputParamHandler(handler: OutputParamHandler) {\n        this.fDSPCode.setOutputParamHandler(handler);\n    }\n    getOutputParamHandler() {\n        return this.fDSPCode.getOutputParamHandler();\n    }\n    callOutputParamHandler(path: string, value: number) {\n        this.fDSPCode.callOutputParamHandler(path, value);\n    }\n\n    setInputParamHandler(handler: InputParamHandler) {\n        this.fDSPCode.setInputParamHandler(handler);\n    }\n    getInputParamHandler() {\n        return this.fDSPCode.getInputParamHandler();\n    }\n    callInputParamHandler(path: string, value: number) {\n        this.fDSPCode.callInputParamHandler(path, value);\n    }\n\n    setComputeHandler(handler: ComputeHandler) {\n        this.fDSPCode.setComputeHandler(handler);\n    }\n    getComputeHandler() {\n        return this.fDSPCode.getComputeHandler();\n    }\n\n    setPlotHandler(handler: PlotHandler) {\n        this.fDSPCode.setPlotHandler(handler);\n    }\n    getPlotHandler() {\n        return this.fDSPCode.getPlotHandler();\n    }\n\n    getNumInputs() {\n        return this.fDSPCode.getNumInputs();\n    }\n    getNumOutputs() {\n        return this.fDSPCode.getNumOutputs();\n    }\n\n    metadata(handler: MetadataHandler) {}\n\n    midiMessage(data: number[] | Uint8Array) {\n        this.fDSPCode.midiMessage(data);\n    }\n\n    ctrlChange(chan: number, ctrl: number, value: number) {\n        this.fDSPCode.ctrlChange(chan, ctrl, value);\n    }\n    pitchWheel(chan: number, value: number) {\n        this.fDSPCode.pitchWheel(chan, value);\n    }\n    keyOn(channel: number, pitch: number, velocity: number) {\n        this.fDSPCode.keyOn(channel, pitch, velocity);\n    }\n    keyOff(channel: number, pitch: number, velocity: number) {\n        this.fDSPCode.keyOff(channel, pitch, velocity);\n    }\n\n    setParamValue(path: string, value: number) {\n        this.fDSPCode.setParamValue(path, value);\n    }\n    getParamValue(path: string) {\n        return this.fDSPCode.getParamValue(path);\n    }\n    getParams() {\n        return this.fDSPCode.getParams();\n    }\n\n    getMeta() {\n        return this.fDSPCode.getMeta();\n    }\n    getJSON() {\n        return this.fDSPCode.getJSON();\n    }\n    getDescriptors() {\n        return this.fDSPCode.getDescriptors();\n    }\n    getUI() {\n        return this.fDSPCode.getUI();\n    }\n\n    start() {\n        this.fDSPCode.start();\n    }\n    stop() {\n        this.fDSPCode.stop();\n    }\n\n    destroy() {\n        this.fDSPCode.destroy();\n    }\n\n    get hasAccInput() {\n        return this.fDSPCode.hasAccInput;\n    }\n\n    propagateAcc(\n        accelerationIncludingGravity: NonNullable<\n            DeviceMotionEvent['accelerationIncludingGravity']\n        >,\n        invert: boolean = false\n    ) {\n        this.fDSPCode.propagateAcc(accelerationIncludingGravity, invert);\n    }\n\n    get hasGyrInput() {\n        return this.fDSPCode.hasGyrInput;\n    }\n\n    propagateGyr(\n        event: Pick<DeviceOrientationEvent, 'alpha' | 'beta' | 'gamma'>\n    ) {\n        this.fDSPCode.propagateGyr(event);\n    }\n\n    startSensors(): void {}\n\n    stopSensors(): void {}\n\n    /**\n     * Render frames in an array.\n     *\n     * @param inputs - input signal\n     * @param length - the number of frames to render (default: bufferSize)\n     * @param onUpdate - a callback after each buffer calculated, with an argument \"current sample\"\n     * @return an array of Float32Array with the rendered frames\n     */\n    render(\n        inputs: Float32Array[] = [],\n        length = this.fBufferSize,\n        onUpdate?: (sample: number) => any\n    ): Float32Array[] {\n        let l = 0;\n        const outputs = new Array(this.fDSPCode.getNumOutputs())\n            .fill(null)\n            .map(() => new Float32Array(length));\n        // The node has to be started before rendering\n        this.fDSPCode.start();\n        while (l < length) {\n            const sliceLength = Math.min(length - l, this.fBufferSize);\n            for (let i = 0; i < this.fDSPCode.getNumInputs(); i++) {\n                let input: Float32Array;\n                if (inputs[i]) {\n                    if (inputs[i].length <= l) {\n                        input = new Float32Array(sliceLength);\n                    } else if (inputs[i].length > l + sliceLength) {\n                        input = inputs[i].subarray(l, l + sliceLength);\n                    } else {\n                        input = inputs[i].subarray(l, inputs[i].length);\n                    }\n                } else {\n                    input = new Float32Array(sliceLength);\n                }\n                this.fInputs[i] = input;\n            }\n            this.fDSPCode.compute(this.fInputs, this.fOutputs);\n            for (let i = 0; i < this.fDSPCode.getNumOutputs(); i++) {\n                const output = this.fOutputs[i];\n                if (sliceLength < this.fBufferSize) {\n                    outputs[i].set(output.subarray(0, sliceLength), l);\n                } else {\n                    outputs[i].set(output, l);\n                }\n            }\n            l += this.fBufferSize;\n            onUpdate?.(l);\n        }\n        // The node can be stopped after rendering\n        this.fDSPCode.stop();\n        return outputs;\n    }\n}\n\nexport class FaustMonoOfflineProcessor\n    extends FaustOfflineProcessor<false>\n    implements IFaustMonoWebAudioDsp {}\n\nexport class FaustPolyOfflineProcessor\n    extends FaustOfflineProcessor<true>\n    implements IFaustPolyWebAudioDsp\n{\n    keyOn(channel: number, pitch: number, velocity: number) {\n        this.fDSPCode.keyOn(channel, pitch, velocity);\n    }\n    keyOff(channel: number, pitch: number, velocity: number) {\n        this.fDSPCode.keyOff(channel, pitch, velocity);\n    }\n    allNotesOff(hard: boolean) {\n        this.fDSPCode.allNotesOff(hard);\n    }\n}\n\nexport default FaustOfflineProcessor;\n", "import type FaustCompiler from './FaustCompiler';\n\ninterface IFaustSvgDiagrams {\n    /**\n     * Generates auxiliary files from Faust code. The output depends on the compiler options.\n     *\n     * @param name - the DSP's name\n     * @param code - Faust code\n     * @param args - compilation args\n     * @returns the svg diagrams as a filename - svg string map\n     */\n    from(name: string, code: string, args: string): Record<string, string>;\n}\n\nclass FaustSvgDiagrams implements IFaustSvgDiagrams {\n    private compiler: FaustCompiler;\n\n    constructor(compiler: FaustCompiler) {\n        this.compiler = compiler;\n    }\n\n    from(name: string, code: string, args: string) {\n        const fs = this.compiler.fs();\n        try {\n            const files: string[] = fs.readdir(`/${name}-svg/`);\n            files\n                .filter((file) => file !== '.' && file !== '..')\n                .forEach((file) => fs.unlink(`/${name}-svg/${file}`));\n        } catch {}\n        const success = this.compiler.generateAuxFiles(\n            name,\n            code,\n            `-lang wasm -o binary -svg ${args}`\n        );\n        if (!success) throw new Error(this.compiler.getErrorMessage());\n        const svgs: Record<string, string> = {};\n        const files: string[] = fs.readdir(`/${name}-svg/`);\n        files\n            .filter((file) => file !== '.' && file !== '..')\n            .forEach(\n                (file) =>\n                    (svgs[file] = fs.readFile(`/${name}-svg/${file}`, {\n                        encoding: 'utf8'\n                    }) as string)\n            );\n        return svgs;\n    }\n}\n\nexport default FaustSvgDiagrams;\n", "import type FaustCompiler from './FaustCompiler';\n\ninterface IFaustCmajor {\n    /**\n     * Generates auxiliary files from Faust code. The output depends on the compiler options.\n     *\n     * @param name - the DSP's name\n     * @param code - Faust code\n     * @param args - compilation args\n     * @returns the Cmajor compiled string\n     */\n    compile(name: string, code: string, args: string): string;\n}\n\nclass FaustCmajor implements IFaustCmajor {\n    private fCompiler: FaustCompiler;\n\n    constructor(compiler: FaustCompiler) {\n        this.fCompiler = compiler;\n    }\n\n    compile(name: string, code: string, args: string) {\n        const fs = this.fCompiler.fs();\n        const success = this.fCompiler.generateAuxFiles(\n            name,\n            code,\n            `-lang cmajor-hybrid -cn ${name} -o ${name}.cmajor`\n        );\n        return success\n            ? (fs.readFile(`${name}.cmajor`, { encoding: 'utf8' }) as string)\n            : '';\n    }\n}\n\nexport default FaustCmajor;\n", "import type { FaustModule, LibFaustWasm, FaustInfoType } from './types';\n\nexport interface ILibFaust extends LibFaustWasm {\n    module(): FaustModule;\n    fs(): typeof FS;\n}\n\nclass LibFaust implements ILibFaust {\n    private fModule: FaustModule;\n    private fCompiler: LibFaustWasm;\n    private fFileSystem: typeof FS;\n\n    constructor(module: FaustModule) {\n        this.fModule = module;\n        this.fCompiler = new module.libFaustWasm();\n        this.fFileSystem = this.fModule.FS;\n    }\n    module() {\n        return this.fModule;\n    }\n    fs() {\n        return this.fFileSystem;\n    }\n    version() {\n        return this.fCompiler.version();\n    }\n    createDSPFactory(\n        name: string,\n        code: string,\n        args: string,\n        useInternalMemory: boolean\n    ) {\n        return this.fCompiler.createDSPFactory(\n            name,\n            code,\n            args,\n            useInternalMemory\n        );\n    }\n    deleteDSPFactory(cFactory: number) {\n        return this.fCompiler.deleteDSPFactory(cFactory);\n    }\n    expandDSP(name: string, code: string, args: string) {\n        return this.fCompiler.expandDSP(name, code, args);\n    }\n    generateAuxFiles(name: string, code: string, args: string) {\n        return this.fCompiler.generateAuxFiles(name, code, args);\n    }\n    deleteAllDSPFactories() {\n        return this.fCompiler.deleteAllDSPFactories();\n    }\n    getErrorAfterException() {\n        return this.fCompiler.getErrorAfterException();\n    }\n    cleanupAfterException() {\n        return this.fCompiler.cleanupAfterException();\n    }\n    getInfos(what: FaustInfoType) {\n        return this.fCompiler.getInfos(what);\n    }\n    toString() {\n        return `LibFaust module: ${this.fModule}, compiler: ${this.fCompiler}`;\n    }\n}\n\nexport default LibFaust;\n", "export interface WavEncoderOptions {\n    bitDepth: number;\n    float?: boolean;\n    symmetric?: boolean;\n    shared?: boolean;\n    sampleRate: number;\n}\ninterface Format {\n    formatId: number;\n    float: boolean;\n    symmetric: boolean;\n    numberOfChannels: number;\n    sampleRate: number;\n    length: number;\n    bitDepth: number;\n    byteDepth: number;\n}\n\n/**\n * Code from https://github.com/mohayonao/wav-encoder\n */\nclass WavEncoder {\n    static encode(audioBuffer: Float32Array[], options: WavEncoderOptions) {\n        const numberOfChannels = audioBuffer.length;\n        const length = audioBuffer[0].length;\n        const { shared, float } = options;\n        const bitDepth = float ? 32 : options.bitDepth | 0 || 16;\n        const byteDepth = bitDepth >> 3;\n        const byteLength = length * numberOfChannels * byteDepth;\n        const AB = shared\n            ? globalThis.SharedArrayBuffer || globalThis.ArrayBuffer\n            : globalThis.ArrayBuffer;\n        const ab = new AB((44 + byteLength) * Uint8Array.BYTES_PER_ELEMENT);\n        const dataView = new DataView(ab);\n        const writer = new Writer(dataView);\n        const format: Format = {\n            formatId: float ? 0x0003 : 0x0001,\n            float: !!float,\n            numberOfChannels,\n            sampleRate: options.sampleRate,\n            symmetric: !!options.symmetric,\n            length,\n            bitDepth,\n            byteDepth\n        };\n        this.writeHeader(writer, format);\n        this.writeData(writer, audioBuffer, format);\n        return ab;\n    }\n    private static writeHeader(writer: Writer, format: Format) {\n        const {\n            formatId,\n            sampleRate,\n            bitDepth,\n            numberOfChannels,\n            length,\n            byteDepth\n        } = format;\n        writer.string('RIFF');\n        writer.uint32(writer.dataView.byteLength - 8);\n        writer.string('WAVE');\n        writer.string('fmt ');\n        writer.uint32(16);\n        writer.uint16(formatId);\n        writer.uint16(numberOfChannels);\n        writer.uint32(sampleRate);\n        writer.uint32(sampleRate * numberOfChannels * byteDepth);\n        writer.uint16(numberOfChannels * byteDepth);\n        writer.uint16(bitDepth);\n        writer.string('data');\n        writer.uint32(length * numberOfChannels * byteDepth);\n        return writer.pos;\n    }\n    private static writeData(\n        writer: Writer,\n        audioBuffer: Float32Array[],\n        format: Format\n    ) {\n        const { bitDepth, float, length, numberOfChannels, symmetric } = format;\n        if (bitDepth === 32 && float) {\n            const { dataView, pos } = writer;\n            const ab = dataView.buffer;\n            const f32View = new Float32Array(ab, pos);\n            if (numberOfChannels === 1) {\n                f32View.set(audioBuffer[0]);\n                return;\n            }\n            for (let ch = 0; ch < numberOfChannels; ch++) {\n                const channel = audioBuffer[ch];\n                for (let i = 0; i < length; i++) {\n                    f32View[i * numberOfChannels + ch] = channel[i];\n                }\n            }\n            return;\n        }\n        const encoderOption = float ? 'f' : symmetric ? 's' : '';\n        const methodName = 'pcm' + bitDepth + encoderOption;\n\n        if (!(writer as any)[methodName]) {\n            throw new TypeError('Not supported bit depth: ' + bitDepth);\n        }\n\n        const write: (value: number) => void = (writer as any)[methodName].bind(\n            writer\n        );\n\n        for (let i = 0; i < length; i++) {\n            for (let j = 0; j < numberOfChannels; j++) {\n                write(audioBuffer[j][i]);\n            }\n        }\n    }\n}\n\nclass Writer {\n    pos = 0;\n    dataView: DataView;\n    constructor(dataView: DataView) {\n        this.dataView = dataView;\n    }\n    int16(value: number) {\n        this.dataView.setInt16(this.pos, value, true);\n        this.pos += 2;\n    }\n    uint16(value: number) {\n        this.dataView.setUint16(this.pos, value, true);\n        this.pos += 2;\n    }\n    uint32(value: number) {\n        this.dataView.setUint32(this.pos, value, true);\n        this.pos += 4;\n    }\n    string(value: string) {\n        for (let i = 0, imax = value.length; i < imax; i++) {\n            this.dataView.setUint8(this.pos++, value.charCodeAt(i));\n        }\n    }\n    pcm8(valueIn: number) {\n        let value = valueIn;\n        value = Math.max(-1, Math.min(value, +1));\n        value = (value * 0.5 + 0.5) * 255;\n        value = Math.round(value) | 0;\n        this.dataView.setUint8(this.pos, value /* , true*/);\n        this.pos += 1;\n    }\n    pcm8s(valueIn: number) {\n        let value = valueIn;\n        value = Math.round(value * 128) + 128;\n        value = Math.max(0, Math.min(value, 255));\n        this.dataView.setUint8(this.pos, value /* , true*/);\n        this.pos += 1;\n    }\n    pcm16(valueIn: number) {\n        let value = valueIn;\n        value = Math.max(-1, Math.min(value, +1));\n        value = value < 0 ? value * 32768 : value * 32767;\n        value = Math.round(value) | 0;\n        this.dataView.setInt16(this.pos, value, true);\n        this.pos += 2;\n    }\n    pcm16s(valueIn: number) {\n        let value = valueIn;\n        value = Math.round(value * 32768);\n        value = Math.max(-32768, Math.min(value, 32767));\n        this.dataView.setInt16(this.pos, value, true);\n        this.pos += 2;\n    }\n    pcm24(valueIn: number) {\n        let value = valueIn;\n        value = Math.max(-1, Math.min(value, +1));\n        value = value < 0 ? 0x1000000 + value * 8388608 : value * 8388607;\n        value = Math.round(value) | 0;\n\n        const x0 = (value >> 0) & 0xff;\n        const x1 = (value >> 8) & 0xff;\n        const x2 = (value >> 16) & 0xff;\n\n        this.dataView.setUint8(this.pos + 0, x0);\n        this.dataView.setUint8(this.pos + 1, x1);\n        this.dataView.setUint8(this.pos + 2, x2);\n        this.pos += 3;\n    }\n    pcm24s(valueIn: number) {\n        let value = valueIn;\n        value = Math.round(value * 8388608);\n        value = Math.max(-8388608, Math.min(value, 8388607));\n\n        const x0 = (value >> 0) & 0xff;\n        const x1 = (value >> 8) & 0xff;\n        const x2 = (value >> 16) & 0xff;\n\n        this.dataView.setUint8(this.pos + 0, x0);\n        this.dataView.setUint8(this.pos + 1, x1);\n        this.dataView.setUint8(this.pos + 2, x2);\n        this.pos += 3;\n    }\n    pcm32(valueIn: number) {\n        let value = valueIn;\n        value = Math.max(-1, Math.min(value, +1));\n        value = value < 0 ? value * 2147483648 : value * 2147483647;\n        value = Math.round(value) | 0;\n        this.dataView.setInt32(this.pos, value, true);\n        this.pos += 4;\n    }\n    pcm32s(valueIn: number) {\n        let value = valueIn;\n        value = Math.round(value * 2147483648);\n        value = Math.max(-2147483648, Math.min(value, +2147483647));\n        this.dataView.setInt32(this.pos, value, true);\n        this.pos += 4;\n    }\n    pcm32f(value: number) {\n        this.dataView.setFloat32(this.pos, value, true);\n        this.pos += 4;\n    }\n}\n\nexport default WavEncoder;\n", "export interface WavDecoderOptions {\n    symmetric?: boolean;\n    shared?: boolean;\n}\ninterface Format {\n    formatId: number;\n    float: boolean;\n    numberOfChannels: number;\n    sampleRate: number;\n    byteRate: number;\n    blockSize: number;\n    bitDepth: number;\n}\n\n/**\n * Code from https://github.com/mohayonao/wav-decoder\n */\nclass WavDecoder {\n    static decode(buffer: ArrayBuffer, options?: WavDecoderOptions) {\n        const dataView = new DataView(buffer);\n        const reader = new Reader(dataView);\n        if (reader.string(4) !== 'RIFF') {\n            throw new TypeError('Invalid WAV file');\n        }\n        reader.uint32(); // skip file length\n        if (reader.string(4) !== 'WAVE') {\n            throw new TypeError('Invalid WAV file');\n        }\n        let format: Format | null = null;\n        let audioData: {\n            numberOfChannels: number;\n            length: number;\n            sampleRate: number;\n            channelData: Float32Array[];\n        } | null = null;\n        do {\n            const chunkType = reader.string(4);\n            const chunkSize = reader.uint32();\n            if (chunkType === 'fmt ') {\n                format = this.decodeFormat(reader, chunkSize);\n            } else if (chunkType === 'data') {\n                audioData = this.decodeData(\n                    reader,\n                    chunkSize,\n                    format as Format,\n                    options || {}\n                );\n            } else {\n                reader.skip(chunkSize);\n            }\n        } while (audioData === null);\n        return audioData;\n    }\n    private static decodeFormat(reader: Reader, chunkSize: number) {\n        const formats = {\n            0x0001: 'lpcm',\n            0x0003: 'lpcm'\n        };\n        const formatId = reader.uint16();\n        if (!Object.prototype.hasOwnProperty.call(formats, formatId)) {\n            throw new TypeError(\n                'Unsupported format in WAV file: 0x' + formatId.toString(16)\n            );\n        }\n        const format: Format = {\n            formatId: formatId,\n            float: formatId === 0x0003,\n            numberOfChannels: reader.uint16(),\n            sampleRate: reader.uint32(),\n            byteRate: reader.uint32(),\n            blockSize: reader.uint16(),\n            bitDepth: reader.uint16()\n        };\n        reader.skip(chunkSize - 16);\n        return format;\n    }\n    private static decodeData(\n        reader: Reader,\n        chunkSizeIn: number,\n        format: Format,\n        options: WavDecoderOptions\n    ) {\n        const chunkSize = Math.min(chunkSizeIn, reader.remain());\n        const length = Math.floor(chunkSize / format.blockSize);\n        const numberOfChannels = format.numberOfChannels;\n        const sampleRate = format.sampleRate;\n        const channelData: Float32Array[] = new Array(numberOfChannels);\n        for (let ch = 0; ch < numberOfChannels; ch++) {\n            const AB = options.shared\n                ? globalThis.SharedArrayBuffer || globalThis.ArrayBuffer\n                : globalThis.ArrayBuffer;\n            const ab = new AB(length * Float32Array.BYTES_PER_ELEMENT);\n            channelData[ch] = new Float32Array(ab);\n        }\n        this.readPCM(reader, channelData, length, format, options);\n        return {\n            numberOfChannels,\n            length,\n            sampleRate,\n            channelData\n        };\n    }\n    private static readPCM(\n        reader: Reader,\n        channelData: Float32Array[],\n        length: number,\n        format: Format,\n        options: WavDecoderOptions\n    ) {\n        const bitDepth = format.bitDepth;\n        const decoderOption = format.float ? 'f' : options.symmetric ? 's' : '';\n        const methodName = ('pcm' +\n            bitDepth +\n            decoderOption) as `pcm${8 | 16 | 32}${'f' | 's' | ''}`;\n        if (!(reader as any)[methodName]) {\n            throw new TypeError('Not supported bit depth: ' + format.bitDepth);\n        }\n        const read: () => number = (reader as any)[methodName].bind(reader);\n        const numberOfChannels = format.numberOfChannels;\n        for (let i = 0; i < length; i++) {\n            for (let ch = 0; ch < numberOfChannels; ch++) {\n                channelData[ch][i] = read();\n            }\n        }\n    }\n}\n\nclass Reader {\n    pos = 0;\n    dataView: DataView;\n    constructor(dataView: DataView) {\n        this.dataView = dataView;\n    }\n    remain() {\n        return this.dataView.byteLength - this.pos;\n    }\n    skip(n: number) {\n        this.pos += n;\n    }\n    uint8() {\n        const data = this.dataView.getUint8(this.pos);\n        this.pos += 1;\n        return data;\n    }\n    int16() {\n        const data = this.dataView.getInt16(this.pos, true);\n        this.pos += 2;\n        return data;\n    }\n    uint16() {\n        const data = this.dataView.getUint16(this.pos, true);\n        this.pos += 2;\n        return data;\n    }\n    uint32() {\n        const data = this.dataView.getUint32(this.pos, true);\n        this.pos += 4;\n        return data;\n    }\n    string(n: number) {\n        let data = '';\n        for (let i = 0; i < n; i++) {\n            data += String.fromCharCode(this.uint8());\n        }\n        return data;\n    }\n    pcm8() {\n        const data = this.dataView.getUint8(this.pos) - 128;\n        this.pos += 1;\n        return data < 0 ? data / 128 : data / 127;\n    }\n    pcm8s() {\n        const data = this.dataView.getUint8(this.pos) - 127.5;\n        this.pos += 1;\n        return data / 127.5;\n    }\n    pcm16() {\n        const data = this.dataView.getInt16(this.pos, true);\n        this.pos += 2;\n        return data < 0 ? data / 32768 : data / 32767;\n    }\n    pcm16s() {\n        const data = this.dataView.getInt16(this.pos, true);\n        this.pos += 2;\n        return data / 32768;\n    }\n    pcm24() {\n        const x0 = this.dataView.getUint8(this.pos + 0);\n        const x1 = this.dataView.getUint8(this.pos + 1);\n        const x2 = this.dataView.getUint8(this.pos + 2);\n        const xx = x0 + (x1 << 8) + (x2 << 16);\n\n        const data = xx > 0x800000 ? xx - 0x1000000 : xx;\n        this.pos += 3;\n        return data < 0 ? data / 8388608 : data / 8388607;\n    }\n    pcm24s() {\n        const x0 = this.dataView.getUint8(this.pos + 0);\n        const x1 = this.dataView.getUint8(this.pos + 1);\n        const x2 = this.dataView.getUint8(this.pos + 2);\n        const xx = x0 + (x1 << 8) + (x2 << 16);\n\n        const data = xx > 0x800000 ? xx - 0x1000000 : xx;\n        this.pos += 3;\n        return data / 8388608;\n    }\n    pcm32() {\n        const data = this.dataView.getInt32(this.pos, true);\n        this.pos += 4;\n        return data < 0 ? data / 2147483648 : data / 2147483647;\n    }\n    pcm32s() {\n        const data = this.dataView.getInt32(this.pos, true);\n        this.pos += 4;\n        return data / 2147483648;\n    }\n    pcm32f() {\n        const data = this.dataView.getFloat32(this.pos, true);\n        this.pos += 4;\n        return data;\n    }\n    pcm64f() {\n        const data = this.dataView.getFloat64(this.pos, true);\n        this.pos += 8;\n        return data;\n    }\n}\n\nexport default WavDecoder;\n", "import { FaustBaseWebAudioDsp } from './FaustWebAudioDsp';\nimport type {\n    AudioData,\n    FaustDspMeta,\n    FaustUIItem,\n    LooseFaustDspFactory\n} from './types';\n\n/** Read metadata and fetch soundfiles */\nclass SoundfileReader {\n    /**\n     * Set fallback base URLs used to resolve soundfile paths.\n     *\n     * In Node or other non-browser runtimes, `location` may be undefined;\n     * in that case this returns an empty list to avoid resolution errors.\n     */\n    static get fallbackPaths() {\n        const loc =\n            typeof location !== 'undefined' ? (location as Location) : null;\n        const href = loc?.href;\n        const origin = loc?.origin;\n        const parent = href ? this.getParentUrl(href) : null;\n        return [href, parent, origin].filter(\n            (value): value is string => typeof value === 'string' && value.length > 0\n        );\n    }\n\n    /**\n     * Extract the parent URL from an URL.\n     * @param url : the URL\n     * @returns : the parent URL\n     */\n    private static getParentUrl(url: string) {\n        return url.substring(0, url.lastIndexOf('/') + 1);\n    }\n\n    /**\n     * Convert an audio buffer to audio data.\n     *\n     * @param audioBuffer : the audio buffer to convert\n     * @returns : the audio data\n     */\n    private static toAudioData(audioBuffer: AudioBuffer): AudioData {\n        const { sampleRate, numberOfChannels } = audioBuffer;\n        return {\n            sampleRate,\n            audioBuffer: new Array(numberOfChannels)\n                .fill(null)\n                .map((v, i) => audioBuffer.getChannelData(i))\n        } as AudioData;\n    }\n\n    /**\n     * Extract the URLs from the metadata.\n     *\n     * @param dspMeta : the metadata\n     * @returns : the URLs\n     */\n    static findSoundfilesFromMeta(\n        dspMeta: FaustDspMeta\n    ): LooseFaustDspFactory['soundfiles'] {\n        const soundfiles: LooseFaustDspFactory['soundfiles'] = {};\n        const callback = (item: FaustUIItem) => {\n            if (item.type === 'soundfile') {\n                const urls = FaustBaseWebAudioDsp.splitSoundfileNames(item.url);\n                // soundfiles.map[item.label] = urls;\n                urls.forEach((url) => (soundfiles[url] = null));\n            }\n        };\n        FaustBaseWebAudioDsp.parseUI(dspMeta.ui, callback);\n        return soundfiles;\n    }\n    /**\n     * Check if the file exists.\n     *\n     * @param url : the url of the file to check\n     * @returns : true if the file exists, otherwise false\n     */\n    private static async checkFileExists(url: string): Promise<boolean> {\n        try {\n            console.log(`\"checkFileExists\" url: ${url}`);\n            // Fetch in \"HEAD\" mode does not properly work with the service-worker.js cache, so use \"GET\" mode for now\n            //const response = await fetch(url, { method: \"HEAD\" });\n            const response = await fetch(url);\n            console.log(`\"checkFileExists\" response.ok: ${response.ok}`);\n            return response.ok; // Will be true if the status code is 200-299\n        } catch (error) {\n            console.error('Fetch error:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Fetch the soundfile.\n     *\n     * @param url : the url of the soundfile\n     * @param audioCtx : the audio context\n     * @returns : the audio data\n     */\n    private static async fetchSoundfile(\n        url: string,\n        audioCtx: BaseAudioContext\n    ): Promise<AudioData> {\n        console.log(`Loading sound file from ${url}`);\n        const response = await fetch(url);\n        if (!response.ok)\n            throw new Error(\n                `Failed to load sound file from ${url}: ${response.statusText}`\n            );\n        // Decode the audio data\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);\n        return this.toAudioData(audioBuffer);\n    }\n\n    /**\n     * Load the soundfile.\n     *\n     * @param filename : the filename\n     * @param metaUrls : the metadata URLs\n     * @param soundfiles : the soundfiles\n     * @param audioCtx : the audio context\n     */\n    private static async loadSoundfile(\n        filename: string,\n        metaUrls: string[],\n        soundfiles: LooseFaustDspFactory['soundfiles'],\n        audioCtx: BaseAudioContext\n    ): Promise<void> {\n        if (soundfiles?.[filename]) return;\n        const urlsToCheck = [\n            filename,\n            ...[...metaUrls, ...this.fallbackPaths].map(\n                (path) =>\n                    new URL(filename, path.endsWith('/') ? path : `${path}/`)\n                        .href\n            )\n        ];\n        const checkResults = await Promise.all(\n            urlsToCheck.map((url) => this.checkFileExists(url))\n        );\n        const successIndex = checkResults.findIndex((r) => !!r);\n        if (successIndex === -1)\n            throw new Error(\n                `Failed to load sound file ${filename}, all check failed.`\n            );\n        soundfiles![filename] = await this.fetchSoundfile(\n            urlsToCheck[successIndex],\n            audioCtx\n        );\n    }\n\n    /**\n     * Load the soundfiles, public API.\n     *\n     * @param dspMeta : the metadata\n     * @param soundfilesIn : the soundfiles\n     * @param audioCtx : the audio context\n     * @returns : the soundfiles\n     */\n    static async loadSoundfiles(\n        dspMeta: FaustDspMeta,\n        soundfilesIn: LooseFaustDspFactory['soundfiles'],\n        audioCtx: BaseAudioContext\n    ): Promise<LooseFaustDspFactory['soundfiles']> {\n        const metaUrls = FaustBaseWebAudioDsp.extractUrlsFromMeta(dspMeta);\n        const soundfiles = this.findSoundfilesFromMeta(dspMeta);\n        for (const id in soundfiles) {\n            if (soundfilesIn?.[id]) {\n                soundfiles[id] = soundfilesIn[id];\n                continue;\n            }\n            try {\n                await this.loadSoundfile(id, metaUrls, soundfiles, audioCtx);\n            } catch (error) {\n                console.error(error);\n            }\n        }\n        return soundfiles;\n    }\n}\n\nexport default SoundfileReader;\n", "/**\n * Layout:\n *\n *\n * invert-isAndroid (uint8)\n * new-acc-data-available (uint8)\n * new-gyr-data-available (uint8)\n * empty (uint8)\n *\n * acc.x, acc.y, acc.z (f32)\n *\n * gyr.alpha, gyr.beta, gyr.gamma (f32)\n */\nexport class FaustAudioWorkletCommunicator {\n    protected readonly port: MessagePort;\n    protected readonly supportSharedArrayBuffer: boolean;\n    protected readonly byteLength: number;\n    protected uin8Invert: Uint8ClampedArray;\n    protected uin8NewAccData: Uint8ClampedArray;\n    protected uin8NewGyrData: Uint8ClampedArray;\n    protected f32Acc: Float32Array;\n    protected f32Gyr: Float32Array;\n    constructor(port: MessagePort) {\n        this.port = port;\n        this.supportSharedArrayBuffer = !!globalThis.SharedArrayBuffer;\n        this.byteLength =\n            4 * Uint8Array.BYTES_PER_ELEMENT +\n            3 * Float32Array.BYTES_PER_ELEMENT +\n            3 * Float32Array.BYTES_PER_ELEMENT;\n    }\n    initializeBuffer(ab: SharedArrayBuffer | ArrayBuffer) {\n        let ptr = 0;\n        this.uin8Invert = new Uint8ClampedArray(ab, ptr, 1);\n        ptr += Uint8ClampedArray.BYTES_PER_ELEMENT;\n        this.uin8NewAccData = new Uint8ClampedArray(ab, ptr, 1);\n        ptr += Uint8ClampedArray.BYTES_PER_ELEMENT;\n        this.uin8NewGyrData = new Uint8ClampedArray(ab, ptr, 1);\n        ptr += Uint8ClampedArray.BYTES_PER_ELEMENT;\n        ptr += Uint8ClampedArray.BYTES_PER_ELEMENT; // empty\n        this.f32Acc = new Float32Array(ab, ptr, 3);\n        ptr += 3 * Float32Array.BYTES_PER_ELEMENT;\n        this.f32Gyr = new Float32Array(ab, ptr, 3);\n        ptr += 3 * Float32Array.BYTES_PER_ELEMENT;\n    }\n    setNewAccDataAvailable(value: boolean) {\n        if (!this.uin8NewAccData) return;\n        this.uin8NewAccData[0] = +value;\n    }\n    getNewAccDataAvailable() {\n        return !!this.uin8NewAccData?.[0];\n    }\n    setNewGyrDataAvailable(value: boolean) {\n        if (!this.uin8NewGyrData) return;\n        this.uin8NewGyrData[0] = +value;\n    }\n    getNewGyrDataAvailable() {\n        return !!this.uin8NewGyrData?.[0];\n    }\n    setAcc({ x, y, z }: { x: number; y: number; z: number }, invert = false) {\n        if (!this.supportSharedArrayBuffer) {\n            const e = { type: 'acc', data: { x, y, z }, invert };\n            this.port.postMessage(e);\n        }\n        if (!this.uin8NewAccData) return;\n        this.uin8Invert[0] = +invert;\n        this.f32Acc[0] = x;\n        this.f32Acc[1] = y;\n        this.f32Acc[2] = z;\n        this.uin8NewAccData[0] = 1;\n    }\n    getAcc() {\n        if (!this.uin8NewAccData) return;\n        const invert = !!this.uin8Invert[0];\n        const [x, y, z] = this.f32Acc;\n        return { x, y, z, invert };\n    }\n    setGyr({\n        alpha,\n        beta,\n        gamma\n    }: {\n        alpha: number;\n        beta: number;\n        gamma: number;\n    }) {\n        if (!this.supportSharedArrayBuffer) {\n            const e = { type: 'gyr', data: { alpha, beta, gamma } };\n            this.port.postMessage(e);\n        }\n        if (!this.uin8NewGyrData) return;\n        this.f32Gyr[0] = alpha;\n        this.f32Gyr[1] = beta;\n        this.f32Gyr[2] = gamma;\n        this.uin8NewGyrData[0] = 1;\n    }\n    getGyr() {\n        if (!this.uin8NewGyrData) return;\n        const [alpha, beta, gamma] = this.f32Gyr;\n        return { alpha, beta, gamma };\n    }\n}\n\nexport class FaustAudioWorkletNodeCommunicator extends FaustAudioWorkletCommunicator {\n    constructor(port: MessagePort) {\n        super(port);\n        if (this.supportSharedArrayBuffer) {\n            const sab = new SharedArrayBuffer(this.byteLength);\n            this.initializeBuffer(sab);\n            this.port.postMessage({ type: 'initSab', sab });\n        } else {\n            const ab = new ArrayBuffer(this.byteLength);\n            this.initializeBuffer(ab);\n        }\n    }\n}\n\nexport class FaustAudioWorkletProcessorCommunicator extends FaustAudioWorkletCommunicator {\n    constructor(port: MessagePort) {\n        super(port);\n\n        if (this.supportSharedArrayBuffer) {\n            this.port.addEventListener('message', (event) => {\n                const { data } = event;\n                if (data.type === 'initSab') {\n                    this.initializeBuffer(data.sab);\n                }\n            });\n        } else {\n            const ab = new ArrayBuffer(this.byteLength);\n            this.initializeBuffer(ab);\n            this.port.addEventListener('message', (event) => {\n                const msg = event.data;\n\n                switch (msg.type) {\n                    // Sensors messages\n                    case 'acc': {\n                        this.setAcc(msg.data, msg.invert);\n                        break;\n                    }\n                    case 'gyr': {\n                        this.setGyr(msg.data);\n                        break;\n                    }\n                    default:\n                        break;\n                }\n            });\n        }\n    }\n}\n", "import {\n    InputParamHandler,\n    OutputParamHandler,\n    ComputeHandler,\n    PlotHandler,\n    UIHandler,\n    MetadataHandler,\n    FaustBaseWebAudioDsp,\n    IFaustMonoWebAudioDsp,\n    IFaustPolyWebAudioDsp\n} from './FaustWebAudioDsp';\nimport type { FaustAudioWorkletNodeOptions } from './FaustAudioWorkletProcessor';\nimport type {\n    LooseFaustDspFactory,\n    FaustDspMeta,\n    FaustUIInputItem,\n    FaustUIItem\n} from './types';\nimport { FaustAudioWorkletNodeCommunicator } from './FaustAudioWorkletCommunicator';\n\n/**\n * Base class for Monophonic and Polyphonic AudioWorkletNode\n */\nexport class FaustAudioWorkletNode<\n    Poly extends boolean = false\n> extends (globalThis.AudioWorkletNode || null) {\n    protected fJSONDsp: FaustDspMeta;\n    protected fJSON: string;\n    protected fInputsItems: string[];\n    protected fOutputHandler: OutputParamHandler | null;\n    protected fInputHandler: InputParamHandler | null;\n    protected fComputeHandler: ComputeHandler | null;\n    protected fPlotHandler: PlotHandler | null;\n    protected fUICallback: UIHandler;\n    protected fDescriptor: FaustUIInputItem[];\n    protected fCommunicator: FaustAudioWorkletNodeCommunicator;\n    protected fParamAliases: Record<string, string>;\n    #hasAccInput = false;\n    #hasGyrInput = false;\n\n    constructor(\n        context: BaseAudioContext,\n        name: string,\n        factory: LooseFaustDspFactory,\n        options: Partial<FaustAudioWorkletNodeOptions<Poly>> = {}\n    ) {\n        // Create JSON object\n        const JSONObj: FaustDspMeta = JSON.parse(factory.json);\n\n        // Create proxy FaustAudioWorkletProcessor\n        super(context, name, {\n            numberOfInputs: JSONObj.inputs > 0 ? 1 : 0,\n            numberOfOutputs: JSONObj.outputs > 0 ? 1 : 0,\n            channelCount: Math.max(1, JSONObj.inputs),\n            outputChannelCount: [JSONObj.outputs],\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            processorOptions: options.processorOptions,\n            ...options\n        });\n\n        this.fJSONDsp = JSONObj;\n        this.fJSON = factory.json;\n        this.fOutputHandler = null;\n        this.fInputHandler = null;\n        this.fComputeHandler = null;\n        this.fPlotHandler = null;\n        this.fDescriptor = [];\n        this.fParamAliases = {};\n\n        // Parse UI\n        this.fInputsItems = [];\n        this.fUICallback = (item: FaustUIItem) => {\n            if (\n                item.type === 'vslider' ||\n                item.type === 'hslider' ||\n                item.type === 'button' ||\n                item.type === 'checkbox' ||\n                item.type === 'nentry'\n            ) {\n                // Keep inputs adresses\n                this.fInputsItems.push(item.address);\n                this.fDescriptor.push(item);\n                const registerAlias = (alias: string) => {\n                    if (!this.fParamAliases[alias]) {\n                        this.fParamAliases[alias] = item.address;\n                    }\n                };\n                registerAlias(item.shortname);\n                registerAlias(item.label);\n                if (!item.meta) return;\n                item.meta.forEach((meta) => {\n                    const { midi, acc, gyr } = meta;\n                    if (acc) this.#hasAccInput = true;\n                    if (gyr) this.#hasGyrInput = true;\n                });\n            }\n        };\n\n        FaustBaseWebAudioDsp.parseUI(this.fJSONDsp.ui, this.fUICallback);\n\n        this.fCommunicator = new FaustAudioWorkletNodeCommunicator(this.port);\n\n        // Patch it with additional functions\n        this.port.addEventListener('message', this.handleMessageAux);\n        this.port.start();\n    }\n\n    protected handleMessageAux = (e: MessageEvent) => {\n        if (e.data.type === 'out-param' && this.fOutputHandler) {\n            this.fOutputHandler(e.data.path, e.data.value);\n        } else if (e.data.type === 'in-param' && this.fInputHandler) {\n            this.fInputHandler(e.data.path, e.data.value);\n        } else if (e.data.type === 'plot' && this.fPlotHandler) {\n            this.fPlotHandler(e.data.value, e.data.index, e.data.events);\n        }\n    };\n\n    // Accelerometer and gyroscope handlers\n    private handleDeviceMotion = ({\n        accelerationIncludingGravity\n    }: DeviceMotionEvent) => {\n        const isAndroid: boolean = /Android/i.test(navigator.userAgent);\n        if (!accelerationIncludingGravity) return;\n        const { x, y, z } = accelerationIncludingGravity;\n        this.propagateAcc({ x, y, z }, isAndroid);\n    };\n\n    private handleDeviceOrientation = ({\n        alpha,\n        beta,\n        gamma\n    }: DeviceOrientationEvent) => {\n        this.propagateGyr({ alpha, beta, gamma });\n    };\n\n    // Public API\n\n    /** Setup accelerometer and gyroscope handlers */\n    async startSensors() {\n        if (this.hasAccInput) {\n            if (window.DeviceMotionEvent) {\n                // iOS 13+ requires a user gesture to enable DeviceMotionEvent, to be done in the main thread\n                window.addEventListener(\n                    'devicemotion',\n                    this.handleDeviceMotion,\n                    true\n                );\n            } else {\n                // Browser doesn't support DeviceMotionEvent\n                console.log('Cannot set the accelerometer handler.');\n            }\n        }\n        if (this.hasGyrInput) {\n            if (window.DeviceMotionEvent) {\n                // iOS 13+ requires a user gesture to enable DeviceMotionEvent, to be done in the main thread\n                window.addEventListener(\n                    'deviceorientation',\n                    this.handleDeviceOrientation,\n                    true\n                );\n            } else {\n                // Browser doesn't support DeviceMotionEvent\n                console.log('Cannot set the gyroscope handler.');\n            }\n        }\n    }\n\n    stopSensors() {\n        if (this.hasAccInput) {\n            window.removeEventListener(\n                'devicemotion',\n                this.handleDeviceMotion,\n                true\n            );\n        }\n        if (this.hasGyrInput) {\n            window.removeEventListener(\n                'deviceorientation',\n                this.handleDeviceOrientation,\n                true\n            );\n        }\n    }\n\n    setOutputParamHandler(handler: OutputParamHandler | null) {\n        this.fOutputHandler = handler;\n    }\n    getOutputParamHandler() {\n        return this.fOutputHandler;\n    }\n    callOutputParamHandler(path: string, value: number) {\n        if (this.fOutputHandler) {\n            this.fOutputHandler(path, value);\n        }\n    }\n\n    setInputParamHandler(handler: InputParamHandler | null) {\n        this.fInputHandler = handler;\n    }\n    getInputParamHandler() {\n        return this.fInputHandler;\n    }\n    callInputParamHandler(path: string, value: number) {\n        if (this.fInputHandler) {\n            this.fInputHandler(path, value);\n        }\n    }\n\n    setComputeHandler(handler: ComputeHandler | null) {\n        this.fComputeHandler = handler;\n    }\n    getComputeHandler(): ComputeHandler | null {\n        return this.fComputeHandler;\n    }\n\n    setPlotHandler(handler: PlotHandler | null) {\n        this.fPlotHandler = handler;\n        // Set PlotHandler on processor side\n        if (this.fPlotHandler) {\n            this.port.postMessage({ type: 'setPlotHandler', data: true });\n        } else {\n            this.port.postMessage({ type: 'setPlotHandler', data: false });\n        }\n    }\n    getPlotHandler(): PlotHandler | null {\n        return this.fPlotHandler;\n    }\n\n    setupWamEventHandler() {\n        this.port.postMessage({ type: 'setupWamEventHandler' });\n    }\n\n    getNumInputs() {\n        return this.fJSONDsp.inputs;\n    }\n    getNumOutputs() {\n        return this.fJSONDsp.outputs;\n    }\n\n    // Implemented in subclasses\n    compute(inputs: Float32Array[], outputs: Float32Array[]) {\n        return false;\n    }\n\n    metadata(handler: MetadataHandler) {\n        if (this.fJSONDsp.meta) {\n            this.fJSONDsp.meta.forEach((meta) =>\n                handler(Object.keys(meta)[0], meta[Object.keys(meta)[0]])\n            );\n        }\n    }\n\n    midiMessage(data: number[] | Uint8Array): void {\n        const cmd = data[0] >> 4;\n        const channel = data[0] & 0xf;\n        const data1 = data[1];\n        const data2 = data[2];\n        if (cmd === 11) this.ctrlChange(channel, data1, data2);\n        else if (cmd === 14) this.pitchWheel(channel, data2 * 128.0 + data1);\n        if (cmd === 8 || (cmd === 9 && data2 === 0))\n            this.keyOff(channel, data1, data2);\n        else if (cmd === 9) this.keyOn(channel, data1, data2);\n        else this.port.postMessage({ type: 'midi', data: data });\n    }\n\n    ctrlChange(channel: number, ctrl: number, value: number) {\n        const e = { type: 'ctrlChange', data: [channel, ctrl, value] };\n        this.port.postMessage(e);\n    }\n    pitchWheel(channel: number, wheel: number) {\n        const e = { type: 'pitchWheel', data: [channel, wheel] };\n        this.port.postMessage(e);\n    }\n    keyOn(channel: number, pitch: number, velocity: number) {\n        const e = { type: 'keyOn', data: [channel, pitch, velocity] };\n        this.port.postMessage(e);\n    }\n    keyOff(channel: number, pitch: number, velocity: number) {\n        const e = { type: 'keyOff', data: [channel, pitch, velocity] };\n        this.port.postMessage(e);\n    }\n\n    get hasAccInput() {\n        return this.#hasAccInput;\n    }\n\n    propagateAcc(\n        accelerationIncludingGravity: NonNullable<\n            DeviceMotionEvent['accelerationIncludingGravity']\n        >,\n        invert: boolean = false\n    ) {\n        if (!accelerationIncludingGravity) return;\n        const { x, y, z } = accelerationIncludingGravity;\n        this.fCommunicator.setAcc({ x: x!, y: y!, z: z! }, invert);\n    }\n\n    get hasGyrInput() {\n        return this.#hasGyrInput;\n    }\n\n    propagateGyr(\n        event: Pick<DeviceOrientationEvent, 'alpha' | 'beta' | 'gamma'>\n    ) {\n        if (!event) return;\n        const { alpha, beta, gamma } = event;\n        this.fCommunicator.setGyr({\n            alpha: alpha!,\n            beta: beta!,\n            gamma: gamma!\n        });\n    }\n\n    setParamValue(path: string, value: number) {\n        const resolved = this.fParamAliases[path] || path;\n        this.port.postMessage({ type: 'param', data: { path: resolved, value } });\n        // Set value on AudioParam (but this is not used on Processor side for now)\n        const param = this.parameters.get(resolved);\n        if (param) param.setValueAtTime(value, this.context.currentTime);\n    }\n    getParamValue(path: string) {\n        // Get value of AudioParam\n        const resolved = this.fParamAliases[path] || path;\n        const param = this.parameters.get(resolved);\n        return param ? param.value : 0;\n    }\n\n    getParams() {\n        return this.fInputsItems;\n    }\n    getMeta() {\n        return this.fJSONDsp;\n    }\n    getJSON() {\n        return JSON.stringify(this.getMeta());\n    }\n    getUI() {\n        return this.fJSONDsp.ui;\n    }\n    getDescriptors() {\n        return this.fDescriptor;\n    }\n\n    start() {\n        this.port.postMessage({ type: 'start' });\n    }\n\n    stop() {\n        this.port.postMessage({ type: 'stop' });\n    }\n\n    destroy() {\n        this.port.postMessage({ type: 'destroy' });\n        this.port.close();\n    }\n}\n\n/**\n * Monophonic AudioWorkletNode\n */\nexport class FaustMonoAudioWorkletNode\n    extends FaustAudioWorkletNode<false>\n    implements IFaustMonoWebAudioDsp\n{\n    onprocessorerror = (e: Event) => {\n        // console.error(\"Error from \" + this.fJSONDsp.name + \" FaustMonoAudioWorkletNode\");\n        throw e;\n    };\n\n    constructor(\n        context: BaseAudioContext,\n        options: Partial<FaustAudioWorkletNodeOptions<false>> &\n            Pick<FaustAudioWorkletNodeOptions<false>, 'processorOptions'>\n    ) {\n        super(\n            context,\n            options.processorOptions.name,\n            options.processorOptions.factory,\n            options\n        );\n    }\n}\n\n/**\n * Polyphonic AudioWorkletNode\n */\nexport class FaustPolyAudioWorkletNode\n    extends FaustAudioWorkletNode<true>\n    implements IFaustPolyWebAudioDsp\n{\n    private fJSONEffect: FaustDspMeta | null;\n\n    onprocessorerror = (e: Event) => {\n        // console.error(\"Error from \" + this.fJSONDsp.name + \" FaustPolyAudioWorkletNode\");\n        throw e;\n    };\n\n    constructor(\n        context: BaseAudioContext,\n        options: Partial<FaustAudioWorkletNodeOptions<true>> &\n            Pick<FaustAudioWorkletNodeOptions<true>, 'processorOptions'>\n    ) {\n        super(\n            context,\n            options.processorOptions.name,\n            options.processorOptions.voiceFactory,\n            options\n        );\n\n        this.fJSONEffect = options.processorOptions.effectFactory\n            ? JSON.parse(options.processorOptions.effectFactory.json)\n            : null;\n\n        if (this.fJSONEffect) {\n            FaustBaseWebAudioDsp.parseUI(this.fJSONEffect.ui, this.fUICallback);\n        }\n    }\n\n    // Public API\n    keyOn(channel: number, pitch: number, velocity: number) {\n        const e = { type: 'keyOn', data: [channel, pitch, velocity] };\n        this.port.postMessage(e);\n    }\n\n    keyOff(channel: number, pitch: number, velocity: number) {\n        const e = { type: 'keyOff', data: [channel, pitch, velocity] };\n        this.port.postMessage(e);\n    }\n\n    allNotesOff(hard: boolean) {\n        const e = { type: 'ctrlChange', data: [0, 123, 0] };\n        this.port.postMessage(e);\n    }\n\n    getMeta() {\n        const o = this.fJSONDsp;\n        const e = this.fJSONEffect;\n        const r = { ...o };\n        if (e) {\n            r.ui = [\n                {\n                    type: 'tgroup',\n                    label: 'Sequencer',\n                    items: [\n                        { type: 'vgroup', label: 'Instrument', items: o.ui },\n                        { type: 'vgroup', label: 'Effect', items: e.ui }\n                    ]\n                }\n            ];\n        } else {\n            r.ui = [\n                {\n                    type: 'tgroup',\n                    label: 'Polyphonic',\n                    items: [{ type: 'vgroup', label: 'Voices', items: o.ui }]\n                }\n            ];\n        }\n        return r as FaustDspMeta;\n    }\n\n    getJSON() {\n        return JSON.stringify(this.getMeta());\n    }\n\n    getUI() {\n        return this.getMeta().ui;\n    }\n}\n", "import type {\n    ComputeHandler,\n    FaustMonoWebAudioDsp,\n    FaustPolyWebAudioDsp,\n    IFaustMonoWebAudioDsp,\n    IFaustPolyWebAudioDsp,\n    InputParamHandler,\n    MetadataHandler,\n    OutputParamHandler,\n    PlotHandler\n} from './FaustWebAudioDsp';\n\n/**\n * Base class for Monophonic and Polyphonic ScriptProcessorNode\n */\nexport class FaustScriptProcessorNode<\n    Poly extends boolean = false\n> extends (globalThis.ScriptProcessorNode || null) {\n    protected fDSPCode!: Poly extends true\n        ? FaustPolyWebAudioDsp\n        : FaustMonoWebAudioDsp;\n\n    // Needed for ScriptProcessorNode\n    protected fInputs!: Float32Array[];\n    protected fOutputs!: Float32Array[];\n    protected handleDeviceMotion = undefined as any;\n    protected handleDeviceOrientation = undefined as any;\n\n    init(\n        instance: Poly extends true\n            ? FaustPolyWebAudioDsp\n            : FaustMonoWebAudioDsp\n    ) {\n        this.fDSPCode = instance;\n\n        this.fInputs = new Array(this.fDSPCode.getNumInputs());\n        this.fOutputs = new Array(this.fDSPCode.getNumOutputs());\n\n        // Accelerometer and gyroscope handlers\n        this.handleDeviceMotion = ({\n            accelerationIncludingGravity\n        }: DeviceMotionEvent) => {\n            const isAndroid: boolean = /Android/i.test(navigator.userAgent);\n            if (!accelerationIncludingGravity) return;\n            const { x, y, z } = accelerationIncludingGravity;\n            this.propagateAcc({ x, y, z }, isAndroid);\n        };\n\n        this.handleDeviceOrientation = ({\n            alpha,\n            beta,\n            gamma\n        }: DeviceOrientationEvent) => {\n            this.propagateGyr({ alpha, beta, gamma });\n        };\n\n        this.onaudioprocess = (e) => {\n            // Read inputs\n            for (let chan = 0; chan < this.fDSPCode.getNumInputs(); chan++) {\n                this.fInputs[chan] = e.inputBuffer.getChannelData(chan);\n            }\n\n            // Read outputs\n            for (let chan = 0; chan < this.fDSPCode.getNumOutputs(); chan++) {\n                this.fOutputs[chan] = e.outputBuffer.getChannelData(chan);\n            }\n\n            return this.fDSPCode.compute(this.fInputs, this.fOutputs);\n        };\n\n        this.start();\n    }\n\n    // Public API\n\n    /** Start accelerometer and gyroscope handlers */\n    async startSensors() {\n        if (this.hasAccInput) {\n            if (window.DeviceMotionEvent) {\n                // iOS 13+ requires a user gesture to enable DeviceMotionEvent, to be done in the main thread\n                window.addEventListener(\n                    'devicemotion',\n                    this.handleDeviceMotion,\n                    true\n                );\n            } else {\n                // Browser doesn't support DeviceMotionEvent\n                console.log('Cannot set the accelerometer handler.');\n            }\n        }\n        if (this.hasGyrInput) {\n            if (window.DeviceMotionEvent) {\n                // iOS 13+ requires a user gesture to enable DeviceMotionEvent, to be done in the main thread\n                window.addEventListener(\n                    'deviceorientation',\n                    this.handleDeviceOrientation,\n                    true\n                );\n            } else {\n                // Browser doesn't support DeviceMotionEvent\n                console.log('Cannot set the gyroscope handler.');\n            }\n        }\n    }\n\n    /** Stop accelerometer and gyroscope handlers */\n    stopSensors() {\n        if (this.hasAccInput) {\n            window.removeEventListener(\n                'devicemotion',\n                this.handleDeviceMotion,\n                true\n            );\n        }\n        if (this.hasGyrInput) {\n            window.removeEventListener(\n                'deviceorientation',\n                this.handleDeviceOrientation,\n                true\n            );\n        }\n    }\n\n    compute(input: Float32Array[], output: Float32Array[]) {\n        return this.fDSPCode.compute(input, output);\n    }\n\n    setOutputParamHandler(handler: OutputParamHandler) {\n        this.fDSPCode.setOutputParamHandler(handler);\n    }\n    getOutputParamHandler() {\n        return this.fDSPCode.getOutputParamHandler();\n    }\n    callOutputParamHandler(path: string, value: number) {\n        this.fDSPCode.callOutputParamHandler(path, value);\n    }\n\n    setInputParamHandler(handler: InputParamHandler) {\n        this.fDSPCode.setInputParamHandler(handler);\n    }\n    getInputParamHandler() {\n        return this.fDSPCode.getInputParamHandler();\n    }\n    callInputParamHandler(path: string, value: number) {\n        this.fDSPCode.callInputParamHandler(path, value);\n    }\n\n    setComputeHandler(handler: ComputeHandler) {\n        this.fDSPCode.setComputeHandler(handler);\n    }\n    getComputeHandler() {\n        return this.fDSPCode.getComputeHandler();\n    }\n\n    setPlotHandler(handler: PlotHandler) {\n        this.fDSPCode.setPlotHandler(handler);\n    }\n    getPlotHandler() {\n        return this.fDSPCode.getPlotHandler();\n    }\n\n    getNumInputs() {\n        return this.fDSPCode.getNumInputs();\n    }\n    getNumOutputs() {\n        return this.fDSPCode.getNumOutputs();\n    }\n\n    metadata(handler: MetadataHandler) {}\n\n    midiMessage(data: number[] | Uint8Array) {\n        this.fDSPCode.midiMessage(data);\n    }\n\n    ctrlChange(chan: number, ctrl: number, value: number) {\n        this.fDSPCode.ctrlChange(chan, ctrl, value);\n    }\n    pitchWheel(chan: number, value: number) {\n        this.fDSPCode.pitchWheel(chan, value);\n    }\n    keyOn(channel: number, pitch: number, velocity: number) {\n        this.fDSPCode.keyOn(channel, pitch, velocity);\n    }\n    keyOff(channel: number, pitch: number, velocity: number) {\n        this.fDSPCode.keyOff(channel, pitch, velocity);\n    }\n\n    setParamValue(path: string, value: number) {\n        this.fDSPCode.setParamValue(path, value);\n    }\n    getParamValue(path: string) {\n        return this.fDSPCode.getParamValue(path);\n    }\n    getParams() {\n        return this.fDSPCode.getParams();\n    }\n\n    getMeta() {\n        return this.fDSPCode.getMeta();\n    }\n    getJSON() {\n        return this.fDSPCode.getJSON();\n    }\n    getDescriptors() {\n        return this.fDSPCode.getDescriptors();\n    }\n    getUI() {\n        return this.fDSPCode.getUI();\n    }\n\n    start() {\n        this.fDSPCode.start();\n    }\n    stop() {\n        this.fDSPCode.stop();\n    }\n\n    destroy() {\n        this.fDSPCode.destroy();\n    }\n\n    get hasAccInput() {\n        return this.fDSPCode.hasAccInput;\n    }\n\n    propagateAcc(\n        accelerationIncludingGravity: NonNullable<\n            DeviceMotionEvent['accelerationIncludingGravity']\n        >,\n        invert: boolean = false\n    ) {\n        this.fDSPCode.propagateAcc(accelerationIncludingGravity, invert);\n    }\n\n    get hasGyrInput() {\n        return this.fDSPCode.hasGyrInput;\n    }\n\n    propagateGyr(\n        event: Pick<DeviceOrientationEvent, 'alpha' | 'beta' | 'gamma'>\n    ) {\n        this.fDSPCode.propagateGyr(event);\n    }\n}\n\nexport class FaustMonoScriptProcessorNode\n    extends FaustScriptProcessorNode<false>\n    implements IFaustMonoWebAudioDsp {}\n\nexport class FaustPolyScriptProcessorNode\n    extends FaustScriptProcessorNode<true>\n    implements IFaustPolyWebAudioDsp\n{\n    keyOn(channel: number, pitch: number, velocity: number) {\n        this.fDSPCode.keyOn(channel, pitch, velocity);\n    }\n    keyOff(channel: number, pitch: number, velocity: number) {\n        this.fDSPCode.keyOff(channel, pitch, velocity);\n    }\n    allNotesOff(hard: boolean) {\n        this.fDSPCode.allNotesOff(hard);\n    }\n}\n", "import {\n    FaustMonoAudioWorkletNode,\n    FaustPolyAudioWorkletNode\n} from './FaustAudioWorkletNode';\nimport getFaustAudioWorkletProcessor, {\n    FaustData\n} from './FaustAudioWorkletProcessor';\nimport getFaustFFTAudioWorkletProcessor, {\n    FaustFFTData,\n    FaustFFTOptionsData\n} from './FaustFFTAudioWorkletProcessor';\nimport { FaustDspInstance } from './FaustDspInstance';\nimport FaustWasmInstantiator from './FaustWasmInstantiator';\nimport {\n    FaustMonoOfflineProcessor,\n    FaustPolyOfflineProcessor,\n    IFaustMonoOfflineProcessor,\n    IFaustPolyOfflineProcessor\n} from './FaustOfflineProcessor';\nimport {\n    FaustMonoScriptProcessorNode,\n    FaustPolyScriptProcessorNode\n} from './FaustScriptProcessorNode';\nimport {\n    FaustBaseWebAudioDsp,\n    FaustMonoWebAudioDsp,\n    FaustPolyWebAudioDsp,\n    FaustWebAudioDspVoice,\n    IFaustMonoWebAudioNode,\n    IFaustPolyWebAudioNode,\n    Soundfile,\n    WasmAllocator\n} from './FaustWebAudioDsp';\nimport SoundfileReader from './SoundfileReader';\nimport FaustSensors from './FaustSensors';\nimport FaustCompiler, { IFaustCompiler } from './FaustCompiler';\nimport type {\n    FaustDspFactory,\n    FaustUIDescriptor,\n    FaustDspMeta,\n    FFTUtils,\n    LooseFaustDspFactory,\n    AudioData\n} from './types';\nimport {\n    FaustAudioWorkletCommunicator,\n    FaustAudioWorkletProcessorCommunicator\n} from './FaustAudioWorkletCommunicator';\nimport instantiateFaustModuleFromFile from './instantiateFaustModuleFromFile';\nimport LibFaust from './LibFaust';\n\nexport interface GeneratorSupportingSoundfiles {\n    /**\n     * Attach a map of id - audio data, call after `compile()` before `createNode()`\n     *\n     * @param soundfileMap a map of id - `AudioData` as an object where `AudioData` contains channel data as `audioBuffer: Float32Array[]` and `sampleRate: number`\n     */\n    addSoundfiles(soundfileMap: Record<string, AudioData>): void;\n\n    /**\n     * Get a list of soundfiles needed, call after `compile()`\n     */\n    getSoundfileList(): string[];\n}\n\nexport interface IFaustDspGenerator {\n    /**\n     * Create a monophonic or polyphonic WebAudio node (either ScriptProcessorNode or AudioWorkletNode).\n     * Analyze the code to decide whether to create a monophonic or polyphonic node.\n     *\n     * @param context - the WebAudio context\n     * @param name - DSP name, can be used for processorName\n     * @param code - the DSP code\n     * @param sp - whether to compile a ScriptProcessorNode or an AudioWorkletNode\n     * @param bufferSize - the buffer size in frames to be used in ScriptProcessorNode only, since AudioWorkletNode always uses 128 frames\n     * @returns the compiled monophonic or polyphonic WebAudio node or 'null' if failure\n     */\n    createFaustNode(\n        context: BaseAudioContext,\n        name: string,\n        code: string,\n        sp?: boolean,\n        bufferSize?: number,\n    ): Promise<IFaustMonoWebAudioNode | IFaustPolyWebAudioNode | null>;\n}\n\nexport interface IFaustMonoDspGenerator extends GeneratorSupportingSoundfiles {\n    /**\n     * Compile a monophonic DSP factory from given code.\n     *\n     * @param compiler - the Faust compiler\n     * @param name - the DSP name\n     * @param code - the DSP code\n     * @param args - the compilation parameters\n     * @returns the compiled factory or 'null' if failure\n     */\n    compile(\n        compiler: IFaustCompiler,\n        name: string,\n        code: string,\n        args: string\n    ): Promise<{\n        factory: FaustDspFactory | null;\n        name?: string;\n        meta?: FaustDspMeta;\n    } | null>;\n\n    /**\n     * Create a monophonic WebAudio node (either ScriptProcessorNode or AudioWorkletNode).\n     *\n     * @param context - the WebAudio context\n     * @param name - DSP name, can be used for processorName\n     * @param factory - default is the compiled factory\n     * @param sp - whether to compile a ScriptProcessorNode or an AudioWorkletNode\n     * @param bufferSize - the buffer size in frames to be used in ScriptProcessorNode only, since AudioWorkletNode always uses 128 frames\n     * @param processorName - AudioWorklet Processor name\n     * @param processorOptions - Additional AudioWorklet Processor options\n     * @returns the compiled WebAudio node or 'null' if failure\n     */\n    createNode(\n        context: BaseAudioContext,\n        name?: string,\n        factory?: LooseFaustDspFactory,\n        sp?: boolean,\n        bufferSize?: number,\n        processorName?: string,\n        processorOptions?: Record<string, any>\n    ): Promise<IFaustMonoWebAudioNode | null>;\n\n    /**\n     * Create a monophonic WebAudio node (either ScriptProcessorNode or AudioWorkletNode).\n     *\n     * @param context - the WebAudio context\n     * @param fftUtils - should be an anonymous class with static methods, without any import from outside\n     * @param name - DSP name, can be used for processorName\n     * @param factory - default is the compiled factory\n     * @param fftOptions - initial FFT options\n     * @param processorName - AudioWorklet Processor name\n     * @param processorOptions - Additional AudioWorklet Processor options\n     * @returns the compiled WebAudio node or 'null' if failure\n     */\n    createFFTNode(\n        context: BaseAudioContext,\n        fftUtils: typeof FFTUtils,\n        name?: string,\n        factory?: LooseFaustDspFactory,\n        fftOptions?: Partial<FaustFFTOptionsData>,\n        processorName?: string,\n        processorOptions?: Record<string, any>\n    ): Promise<FaustMonoAudioWorkletNode | null>;\n\n    /**\n     * Create a monophonic Offline processor.\n     *\n     * @param sampleRate - the sample rate in Hz\n     * @param bufferSize - the buffer size in frames\n     * @param factory - default is the compiled factory\n     * @param context - if this exists, will be used to fetch soundfiles online\n     * @returns the compiled processor or 'null' if failure\n     */\n    createOfflineProcessor(\n        sampleRate: number,\n        bufferSize: number,\n        factory?: LooseFaustDspFactory,\n        context?: BaseAudioContext\n    ): Promise<IFaustMonoOfflineProcessor | null>;\n\n    /**\n     * Get DSP JSON description with its UI and metadata as object.\n     *\n     * @return the DSP JSON description as object\n     */\n    getMeta(): FaustDspMeta;\n\n    /**\n     * Get DSP JSON description with its UI and metadata.\n     *\n     * @return the DSP JSON description\n     */\n    getJSON(): string;\n\n    /**\n     * Get DSP UI description.\n     *\n     * @return the DSP UI description\n     */\n    getUI(): FaustUIDescriptor;\n}\n\nexport interface IFaustPolyDspGenerator extends GeneratorSupportingSoundfiles {\n    /**\n     * Compile a monophonic DSP factory from given code.\n     *\n     * @param compiler - the Faust compiler\n     * @param name - the DSP name\n     * @param dspCode - the DSP code ('dspCode' can possibly contain an integrated effect)\n     * @param args - the compilation parameters\n     * @param effectCode - optional effect DSP code\n     * @returns the compiled factory or 'null' if failure\n     */\n    compile(\n        compiler: IFaustCompiler,\n        name: string,\n        dspCode: string,\n        args: string,\n        effectCode?: string\n    ): Promise<{\n        voiceFactory: FaustDspFactory | null;\n        effectFactory?: FaustDspFactory | null;\n    } | null>;\n\n    /**\n     * Create a polyphonic WebAudio node (either ScriptProcessorNode or AudioWorkletNode).\n     *\n     * @param context the WebAudio context\n     * @param voices - the number of voices\n     * @param name - AudioWorklet Processor name\n     * @param voiceFactory - the Faust factory for voices, either obtained with a compiler (createDSPFactory) or loaded from files (loadDSPFactory)\n     * @param mixerModule - the wasm Mixer module (loaded from 'mixer32.wasm' or 'mixer64.wasm' files located in the 'faustwasm' package)\n     * @param effectFactory - the Faust factory for the effect, either obtained with a compiler (createDSPFactory) or loaded from files (loadDSPFactory)\n     * @param sp - whether to compile a ScriptProcessorNode or an AudioWorkletNode\n     * @param bufferSize - the buffer size in frames to be used in ScriptProcessorNode only, since AudioWorkletNode always uses 128 frames\n     * @param processorOptions - Additional AudioWorklet Processor options\n     * @returns the compiled WebAudio node or 'null' if failure\n     */\n    createNode(\n        context: BaseAudioContext,\n        voices: number,\n        name?: string,\n        voiceFactory?: LooseFaustDspFactory,\n        mixerModule?: WebAssembly.Module,\n        effectFactory?: LooseFaustDspFactory | null,\n        sp?: boolean,\n        bufferSize?: number,\n        processorName?: string,\n        processorOptions?: Record<string, any>\n    ): Promise<IFaustPolyWebAudioNode | null>;\n\n    /**\n     * Create a monophonic Offline processor.\n     *\n     * @param sampleRate - the sample rate in Hz\n     * @param bufferSize - the buffer size in frames\n     * @param voiceFactory - the Faust factory for voices, either obtained with a compiler (createDSPFactory) or loaded from files (loadDSPFactory)\n     * @param mixerModule - the wasm Mixer module (loaded from 'mixer32.wasm' or 'mixer64.wasm' files)\n     * @param effectFactory - the Faust factory for the effect, either obtained with a compiler (createDSPFactory) or loaded from files (loadDSPFactory)\n     * @param context - if this exists, will be used to fetch soundfiles online\n     * @returns the compiled processor or 'null' if failure\n     */\n    createOfflineProcessor(\n        sampleRate: number,\n        bufferSize: number,\n        voices: number,\n        voiceFactory?: LooseFaustDspFactory,\n        mixerModule?: WebAssembly.Module,\n        effectFactory?: LooseFaustDspFactory | null,\n        context?: BaseAudioContext\n    ): Promise<IFaustPolyOfflineProcessor | null>;\n\n    /**\n     * Get DSP JSON description with its UI and metadata as object.\n     *\n     * @return the DSP JSON description as object\n     */\n    getMeta(): FaustDspMeta;\n\n    /**\n     * Get DSP JSON description with its UI and metadata.\n     *\n     * @return the DSP JSON description\n     */\n    getJSON(): string;\n\n    /**\n     * Get DSP UI description.\n     *\n     * @return the DSP UI description\n     */\n    getUI(): FaustUIDescriptor;\n}\n\nexport class FaustMonoDspGenerator implements IFaustMonoDspGenerator {\n    // Set of all created WorkletProcessors, each of them has to be unique\n    private static gWorkletProcessors: Map<BaseAudioContext, Set<string>> =\n        new Map();\n\n    name: string;\n    factory!: FaustDspFactory | null;\n\n    constructor() {\n        this.factory = null;\n    }\n    async compile(\n        compiler: IFaustCompiler,\n        name: string,\n        code: string,\n        args: string\n    ) {\n        this.factory = await compiler.createMonoDSPFactory(name, code, args);\n        if (this.factory) {\n            this.name = name;\n            return this;\n        } else {\n            return null;\n        }\n    }\n\n    addSoundfiles(soundfileMap: Record<string, AudioData>) {\n        if (!this.factory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n        for (const id in soundfileMap) {\n            this.factory.soundfiles[id] = soundfileMap[id];\n        }\n    }\n    getSoundfileList() {\n        if (!this.factory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n        const meta = JSON.parse(this.factory.json);\n        const map = SoundfileReader.findSoundfilesFromMeta(meta);\n        if (!map) return [];\n        return Object.keys(map);\n    }\n\n    async createNode<SP extends boolean = false>(\n        context: BaseAudioContext,\n        name = this.name,\n        factory = this.factory as LooseFaustDspFactory,\n        sp = false as SP,\n        bufferSize = 1024,\n        processorName = factory?.shaKey || name,\n        processorOptions: Record<string, any> = {}\n    ): Promise<\n        SP extends true\n            ? FaustMonoScriptProcessorNode | null\n            : FaustMonoAudioWorkletNode | null\n    > {\n        if (!factory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n\n        const meta = JSON.parse(factory.json);\n        const sampleSize = meta.compile_options.match('-double') ? 8 : 4;\n        factory.soundfiles = await SoundfileReader.loadSoundfiles(\n            meta,\n            factory.soundfiles || {},\n            context\n        );\n        if (sp) {\n            const instance =\n                await FaustWasmInstantiator.createAsyncMonoDSPInstance(factory);\n            const monoDsp = new FaustMonoWebAudioDsp(\n                instance,\n                context.sampleRate,\n                sampleSize,\n                bufferSize,\n                factory.soundfiles\n            );\n\n            const sp = context.createScriptProcessor(\n                bufferSize,\n                monoDsp.getNumInputs(),\n                monoDsp.getNumOutputs()\n            ) as FaustMonoScriptProcessorNode;\n            Object.setPrototypeOf(sp, FaustMonoScriptProcessorNode.prototype);\n            sp.init(monoDsp);\n            return sp as SP extends true\n                ? FaustMonoScriptProcessorNode\n                : FaustMonoAudioWorkletNode;\n        } else {\n            // Dynamically create AudioWorkletProcessor if code not yet created\n            if (!FaustMonoDspGenerator.gWorkletProcessors.has(context))\n                FaustMonoDspGenerator.gWorkletProcessors.set(\n                    context,\n                    new Set()\n                );\n            if (\n                !FaustMonoDspGenerator.gWorkletProcessors\n                    .get(context)\n                    ?.has(processorName)\n            ) {\n                try {\n                    const processorCode = `\n// DSP name and JSON string for DSP are generated\nconst faustData = ${JSON.stringify({\n                        processorName,\n                        dspName: name,\n                        dspMeta: meta,\n                        poly: false\n                    } as FaustData)};\n// Implementation needed classes of functions\nvar ${FaustDspInstance.name} = ${FaustDspInstance.toString()}\nvar FaustDspInstance = ${FaustDspInstance.name};\nvar ${FaustBaseWebAudioDsp.name} = ${FaustBaseWebAudioDsp.toString()}\nvar FaustBaseWebAudioDsp = ${FaustBaseWebAudioDsp.name};\nvar ${FaustMonoWebAudioDsp.name} = ${FaustMonoWebAudioDsp.toString()}\nvar FaustMonoWebAudioDsp = ${FaustMonoWebAudioDsp.name};\nvar ${FaustWasmInstantiator.name} = ${FaustWasmInstantiator.toString()}\nvar FaustWasmInstantiator = ${FaustWasmInstantiator.name};\nvar ${Soundfile.name} = ${Soundfile.toString()}\nvar Soundfile = ${Soundfile.name};\nvar ${WasmAllocator.name} = ${WasmAllocator.toString()}\nvar WasmAllocator = ${WasmAllocator.name};\nvar ${FaustSensors.name} = ${FaustSensors.toString()}\nvar FaustSensors = ${FaustSensors.name};\nvar ${FaustAudioWorkletCommunicator.name} = ${FaustAudioWorkletCommunicator.toString()}\nvar FaustAudioWorkletCommunicator = ${FaustAudioWorkletCommunicator.name};\nvar ${FaustAudioWorkletProcessorCommunicator.name} = ${FaustAudioWorkletProcessorCommunicator.toString()}\nvar FaustAudioWorkletProcessorCommunicator = ${FaustAudioWorkletProcessorCommunicator.name};\n// Put them in dependencies\nconst dependencies = {\n    FaustBaseWebAudioDsp,\n    FaustMonoWebAudioDsp,\n    FaustWasmInstantiator,\n    FaustAudioWorkletProcessorCommunicator\n};\n// Generate the actual AudioWorkletProcessor code\n(${getFaustAudioWorkletProcessor.toString()})(dependencies, faustData);\n`;\n                    const url = URL.createObjectURL(\n                        new Blob([processorCode], { type: 'text/javascript' })\n                    );\n                    await context.audioWorklet.addModule(url);\n                    // Keep the DSP name\n                    FaustMonoDspGenerator.gWorkletProcessors\n                        .get(context)\n                        ?.add(processorName);\n                } catch (e) {\n                    // console.error(`=> exception raised while running createMonoNode: ${e}`);\n                    // console.error(`=> check that your page is served using https.${e}`);\n                    throw e;\n                }\n            }\n            // Create the AWN\n            const node = new FaustMonoAudioWorkletNode(context, {\n                processorOptions: {\n                    name: processorName,\n                    factory,\n                    sampleSize,\n                    ...processorOptions\n                }\n            });\n\n            return node as SP extends true\n                ? FaustMonoScriptProcessorNode\n                : FaustMonoAudioWorkletNode;\n        }\n    }\n\n    async createFFTNode(\n        context: BaseAudioContext,\n        fftUtils: typeof FFTUtils,\n        name = this.name,\n        factory = this.factory as LooseFaustDspFactory,\n        fftOptions: Partial<FaustFFTOptionsData> = {},\n        processorName = factory?.shaKey ? `${factory.shaKey}_fft` : name,\n        processorOptions: Record<string, any> = {}\n    ): Promise<FaustMonoAudioWorkletNode | null> {\n        if (!factory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n\n        const meta: FaustDspMeta = JSON.parse(factory.json);\n        const sampleSize = meta.compile_options.match('-double') ? 8 : 4;\n        factory.soundfiles = await SoundfileReader.loadSoundfiles(\n            meta,\n            factory.soundfiles || {},\n            context\n        );\n        // Dynamically create AudioWorkletProcessor if code not yet created\n        if (!FaustMonoDspGenerator.gWorkletProcessors.has(context))\n            FaustMonoDspGenerator.gWorkletProcessors.set(context, new Set());\n        if (\n            !FaustMonoDspGenerator.gWorkletProcessors\n                .get(context)\n                ?.has(processorName)\n        ) {\n            try {\n                const processorCode = `\n// DSP name and JSON string for DSP are generated\nconst faustData = ${JSON.stringify({\n                    processorName,\n                    dspName: name,\n                    dspMeta: meta,\n                    fftOptions\n                } as FaustFFTData)};\n// Implementation needed classes of functions\nvar ${FaustDspInstance.name} = ${FaustDspInstance.toString()}\nvar FaustDspInstance = ${FaustDspInstance.name};\nvar ${FaustBaseWebAudioDsp.name} = ${FaustBaseWebAudioDsp.toString()}\nvar FaustBaseWebAudioDsp = ${FaustBaseWebAudioDsp.name};\nvar ${FaustMonoWebAudioDsp.name} = ${FaustMonoWebAudioDsp.toString()}\nvar FaustMonoWebAudioDsp = ${FaustMonoWebAudioDsp.name};\nvar ${FaustWasmInstantiator.name} = ${FaustWasmInstantiator.toString()}\nvar FaustWasmInstantiator = ${FaustWasmInstantiator.name};\nvar ${Soundfile.name} = ${Soundfile.toString()}\nvar Soundfile = ${Soundfile.name};\nvar ${WasmAllocator.name} = ${WasmAllocator.toString()}\nvar WasmAllocator = ${WasmAllocator.name};\nvar ${FaustSensors.name} = ${FaustSensors.toString()}\nvar FaustSensors = ${FaustSensors.name};\nvar ${FaustAudioWorkletCommunicator.name} = ${FaustAudioWorkletCommunicator.toString()}\nvar FaustAudioWorkletCommunicator = ${FaustAudioWorkletCommunicator.name};\nvar ${FaustAudioWorkletProcessorCommunicator.name} = ${FaustAudioWorkletProcessorCommunicator.toString()}\nvar FaustAudioWorkletProcessorCommunicator = ${FaustAudioWorkletProcessorCommunicator.name};\nvar FFTUtils = ${fftUtils.toString()}\n// Put them in dependencies\nconst dependencies = {\n    FaustBaseWebAudioDsp,\n    FaustMonoWebAudioDsp,\n    FaustWasmInstantiator,\n    FaustAudioWorkletProcessorCommunicator,\n    FFTUtils\n};\n// Generate the actual AudioWorkletProcessor code\n(${getFaustFFTAudioWorkletProcessor.toString()})(dependencies, faustData);\n`;\n                const url = URL.createObjectURL(\n                    new Blob([processorCode], { type: 'text/javascript' })\n                );\n                await context.audioWorklet.addModule(url);\n                // Keep the DSP name\n                FaustMonoDspGenerator.gWorkletProcessors\n                    .get(context)\n                    ?.add(processorName);\n            } catch (e) {\n                // console.error(`=> exception raised while running createMonoNode: ${e}`);\n                // console.error(`=> check that your page is served using https.${e}`);\n                throw e;\n            }\n        }\n        // Create the AWN\n        const node = new FaustMonoAudioWorkletNode(context, {\n            channelCount: Math.max(1, Math.ceil(meta.inputs / 3)),\n            outputChannelCount: [Math.ceil(meta.outputs / 2)],\n            processorOptions: {\n                name: processorName,\n                factory,\n                sampleSize,\n                ...processorOptions\n            }\n        });\n        if (fftOptions.fftSize) {\n            const param = node.parameters.get('fftSize');\n            if (param) param.value = fftOptions.fftSize;\n        }\n        if (fftOptions.fftOverlap) {\n            const param = node.parameters.get('fftOverlap');\n            if (param) param.value = fftOptions.fftOverlap;\n        }\n        if (typeof fftOptions.defaultWindowFunction === 'number') {\n            const param = node.parameters.get('windowFunction');\n            if (param) param.value = fftOptions.defaultWindowFunction + 1;\n        }\n        if (typeof fftOptions.noIFFT === 'boolean') {\n            const param = node.parameters.get('noIFFT');\n            if (param) param.value = +fftOptions.noIFFT;\n        }\n        return node;\n    }\n\n    async createAudioWorkletProcessor(\n        name = this.name,\n        factory = this.factory as LooseFaustDspFactory,\n        processorName = factory?.shaKey || name\n    ) {\n        if (!factory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n\n        const meta = JSON.parse(factory.json);\n        const dependencies = {\n            FaustBaseWebAudioDsp,\n            FaustMonoWebAudioDsp,\n            FaustWasmInstantiator,\n            FaustAudioWorkletProcessorCommunicator,\n            FaustPolyWebAudioDsp: undefined,\n            FaustWebAudioDspVoice: undefined\n        };\n        // const sampleSize = meta.compile_options.match(\"-double\") ? 8 : 4;\n        // Dynamically create AudioWorkletProcessor if code not yet created\n        try {\n            // DSP name and JSON string for DSP are generated\n            const faustData = {\n                processorName,\n                dspName: name,\n                dspMeta: meta,\n                poly: false\n            } as FaustData;\n            // Generate the actual AudioWorkletProcessor code\n            const Processor = getFaustAudioWorkletProcessor(\n                dependencies,\n                faustData\n            );\n            return Processor;\n        } catch (e) {\n            // console.error(`=> exception raised while running createMonoNode: ${e}`);\n            // console.error(`=> check that your page is served using https.${e}`);\n            throw e;\n        }\n    }\n\n    async createOfflineProcessor(\n        sampleRate: number,\n        bufferSize: number,\n        factory = this.factory as LooseFaustDspFactory,\n        context?: BaseAudioContext\n    ) {\n        if (!factory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n\n        const meta = JSON.parse(factory.json);\n        const instance =\n            await FaustWasmInstantiator.createAsyncMonoDSPInstance(factory);\n        const sampleSize = meta.compile_options.match('-double') ? 8 : 4;\n        if (context)\n            factory.soundfiles = await SoundfileReader.loadSoundfiles(\n                meta,\n                factory.soundfiles || {},\n                context\n            );\n        const monoDsp = new FaustMonoWebAudioDsp(\n            instance,\n            sampleRate,\n            sampleSize,\n            bufferSize,\n            factory.soundfiles\n        );\n        return new FaustMonoOfflineProcessor(monoDsp, bufferSize);\n    }\n\n    getMeta() {\n        return JSON.parse(this.factory!.json);\n    }\n    getJSON() {\n        return JSON.stringify(this.getMeta());\n    }\n    getUI() {\n        return this.getMeta().ui;\n    }\n}\n\nexport class FaustPolyDspGenerator implements IFaustPolyDspGenerator {\n    // Set of all created WorkletProcessors, each of them has to be unique\n    private static gWorkletProcessors: Map<BaseAudioContext, Set<string>> =\n        new Map();\n\n    name: string;\n    voiceFactory!: FaustDspFactory | null;\n    effectFactory!: FaustDspFactory | null;\n    mixerBuffer!: Uint8Array;\n    mixerModule!: WebAssembly.Module;\n\n    constructor() {\n        this.voiceFactory = null;\n        this.effectFactory = null;\n    }\n    async compile(\n        compiler: IFaustCompiler,\n        name: string,\n        dspCodeAux: string,\n        args: string,\n        // The ${dspCode} has to be added with wrapping new lines to make it properly formatted and ready to compile\n        effectCodeAux = `dsp_code = environment{\n                ${dspCodeAux}\n            };\n            process = dsp_code.effect;`\n    ) {\n        // Try to compile effect, possibly failing\n        try {\n            this.effectFactory = await compiler.createPolyDSPFactory(\n                name,\n                effectCodeAux,\n                args\n            );\n            // Since the effect is processing the same buffers for inputs and outputs (in place processing),\n            // the voice and effect are adapted, possibly clearing buffers\n            if (this.effectFactory) {\n                const effectJSON = JSON.parse(this.effectFactory.json);\n                const dspCode = `\\\n// Voice output is forced to 2, when DSP is stereo or effect has 2 ins or 2 outs,\n// so that the effect can process the 2 channels of the voice\nadaptOut(1,1,1) = _;\nadaptOut(1,1,2) = _ <: _,0;  // The left channel only is kept\nadaptOut(1,2,1) = _ <: _,_;\nadaptOut(1,2,2) = _ <: _,_;\nadaptOut(2,1,1) = _,_;\nadaptOut(2,1,2) = _,_;\nadaptOut(2,2,1) = _,_;\nadaptOut(2,2,2) = _,_;\nadaptor(F) = adaptOut(outputs(F),${effectJSON.inputs},${effectJSON.outputs});\ndsp_code = environment{\n    ${dspCodeAux}\n};\nprocess = dsp_code.process : adaptor(dsp_code.process);\n`;\n                const effectCode = `\\\n// Inputs\nadaptIn(1,1,1) = _;\nadaptIn(1,1,2) = _,_ :> _;  \nadaptIn(1,2,1) = _,_;\nadaptIn(1,2,2) = _,_;\nadaptIn(2,1,1) = _,_ :> _;\nadaptIn(2,1,2) = _,_ :> _;\nadaptIn(2,2,1) = _,_;\nadaptIn(2,2,2) = _,_;\n// Outputs\nadaptOut(1,1) = _ <: _,0;   // The left channel only is kept\nadaptOut(1,2) = _,_;\nadaptOut(2,1) = _ <: _,0;   // The left channel only is kept\nadaptOut(2,2) = _,_;\nadaptorIns(F) = adaptIn(outputs(F),${effectJSON.inputs},${effectJSON.outputs});\nadaptorOuts = adaptOut(${effectJSON.inputs},${effectJSON.outputs});\ndsp_code = environment{\n    ${dspCodeAux}\n};\nprocess = adaptorIns(dsp_code.process) : dsp_code.effect : adaptorOuts;\n`;\n                this.voiceFactory = await compiler.createPolyDSPFactory(\n                    name,\n                    dspCode,\n                    args\n                );\n                try {\n                    // Effect is processing same buffers for inputs and outputs, so has to use -inpl option\n                    this.effectFactory = await compiler.createPolyDSPFactory(\n                        name,\n                        effectCode,\n                        args + ' -inpl'\n                    );\n                } catch (e) {\n                    console.warn(e);\n                }\n            }\n        } catch (e) {\n            // Hack to detect 'undefined effect' symbol error, when no effect is defined in the polyphonic code.\n            // The error message is not printed to avoid confusing the user.\n            const errorMessage =\n                e instanceof Error ? e.message : String(e ?? 'unknown error');\n            if (!errorMessage.includes('undefined symbol : effect')) {\n                console.warn(e);\n            }\n            this.voiceFactory = await compiler.createPolyDSPFactory(\n                name,\n                dspCodeAux,\n                args\n            );\n        }\n\n        if (this.voiceFactory) {\n            this.name = name;\n            const voiceMeta = JSON.parse(this.voiceFactory.json);\n            const isDouble = voiceMeta.compile_options.match('-double');\n            const { mixerBuffer, mixerModule } =\n                await compiler.getAsyncInternalMixerModule(!!isDouble);\n            this.mixerBuffer = mixerBuffer;\n            this.mixerModule = mixerModule;\n            return this;\n        } else {\n            return null;\n        }\n    }\n\n    addSoundfiles(soundfileMap: Record<string, AudioData>) {\n        if (!this.voiceFactory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n        for (const id in soundfileMap) {\n            this.voiceFactory.soundfiles[id] = soundfileMap[id];\n        }\n    }\n    getSoundfileList() {\n        if (!this.voiceFactory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n        const meta = JSON.parse(this.voiceFactory.json);\n        const map = SoundfileReader.findSoundfilesFromMeta(meta);\n        if (!map) return [];\n        if (!this.effectFactory) return Object.keys(map);\n        const effectMeta = JSON.parse(this.effectFactory.json);\n        const effectMap = SoundfileReader.findSoundfilesFromMeta(effectMeta);\n        return Object.keys({ ...effectMap, ...map });\n    }\n\n    async createNode<SP extends boolean = false>(\n        context: BaseAudioContext,\n        voices: number,\n        name = this.name,\n        voiceFactory = this.voiceFactory as LooseFaustDspFactory,\n        mixerModule = this.mixerModule,\n        effectFactory = this.effectFactory as LooseFaustDspFactory | null,\n        sp = false as SP,\n        bufferSize = 1024,\n        processorName = (voiceFactory?.shaKey || '') +\n            (effectFactory?.shaKey || '') || `${name}_poly`,\n        processorOptions = {}\n    ): Promise<\n        SP extends true\n            ? FaustPolyScriptProcessorNode | null\n            : FaustPolyAudioWorkletNode | null\n    > {\n        if (!voiceFactory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n\n        const voiceMeta = JSON.parse(voiceFactory.json);\n        const effectMeta = effectFactory\n            ? JSON.parse(effectFactory.json)\n            : undefined;\n        const sampleSize = voiceMeta.compile_options.match('-double') ? 8 : 4;\n        voiceFactory.soundfiles = await SoundfileReader.loadSoundfiles(\n            voiceMeta,\n            voiceFactory.soundfiles || {},\n            context\n        );\n        if (effectFactory)\n            effectFactory.soundfiles = await SoundfileReader.loadSoundfiles(\n                effectMeta,\n                effectFactory.soundfiles || {},\n                context\n            );\n        if (sp) {\n            const instance =\n                await FaustWasmInstantiator.createAsyncPolyDSPInstance(\n                    voiceFactory,\n                    mixerModule,\n                    voices,\n                    effectFactory || undefined\n                );\n            const soundfiles = {\n                ...effectFactory?.soundfiles,\n                ...voiceFactory.soundfiles\n            };\n            const polyDsp = new FaustPolyWebAudioDsp(\n                instance,\n                context.sampleRate,\n                sampleSize,\n                bufferSize,\n                soundfiles\n            );\n\n            const sp = context.createScriptProcessor(\n                bufferSize,\n                polyDsp.getNumInputs(),\n                polyDsp.getNumOutputs()\n            ) as FaustPolyScriptProcessorNode;\n            Object.setPrototypeOf(sp, FaustPolyScriptProcessorNode.prototype);\n            sp.init(polyDsp);\n            return sp as SP extends true\n                ? FaustPolyScriptProcessorNode\n                : FaustPolyAudioWorkletNode;\n        } else {\n            // Dynamically create AudioWorkletProcessor if code not yet created\n            if (!FaustPolyDspGenerator.gWorkletProcessors.has(context))\n                FaustPolyDspGenerator.gWorkletProcessors.set(\n                    context,\n                    new Set()\n                );\n            if (\n                !FaustPolyDspGenerator.gWorkletProcessors\n                    .get(context)\n                    ?.has(processorName)\n            ) {\n                try {\n                    const processorCode = `\n// DSP name and JSON string for DSP are generated\nconst faustData = ${JSON.stringify({\n                        processorName,\n                        dspName: name,\n                        dspMeta: voiceMeta,\n                        poly: true,\n                        effectMeta\n                    } as FaustData)};\n// Implementation needed classes of functions\nvar ${FaustDspInstance.name} = ${FaustDspInstance.toString()}\nvar FaustDspInstance = ${FaustDspInstance.name};\nvar ${FaustBaseWebAudioDsp.name} = ${FaustBaseWebAudioDsp.toString()}\nvar FaustBaseWebAudioDsp = ${FaustBaseWebAudioDsp.name};\nvar ${FaustPolyWebAudioDsp.name} = ${FaustPolyWebAudioDsp.toString()}\nvar FaustPolyWebAudioDsp = ${FaustPolyWebAudioDsp.name};\nvar ${FaustWebAudioDspVoice.name} = ${FaustWebAudioDspVoice.toString()}\nvar FaustWebAudioDspVoice = ${FaustWebAudioDspVoice.name};\nvar ${FaustWasmInstantiator.name} = ${FaustWasmInstantiator.toString()}\nvar FaustWasmInstantiator = ${FaustWasmInstantiator.name};\nvar ${Soundfile.name} = ${Soundfile.toString()}\nvar Soundfile = ${Soundfile.name};\nvar ${WasmAllocator.name} = ${WasmAllocator.toString()}\nvar WasmAllocator = ${WasmAllocator.name};\nvar ${FaustSensors.name} = ${FaustSensors.toString()}\nvar FaustSensors = ${FaustSensors.name};\nvar ${FaustAudioWorkletCommunicator.name} = ${FaustAudioWorkletCommunicator.toString()}\nvar FaustAudioWorkletCommunicator = ${FaustAudioWorkletCommunicator.name};\nvar ${FaustAudioWorkletProcessorCommunicator.name} = ${FaustAudioWorkletProcessorCommunicator.toString()}\nvar FaustAudioWorkletProcessorCommunicator = ${FaustAudioWorkletProcessorCommunicator.name};\n// Put them in dependencies\nconst dependencies = {\n    FaustBaseWebAudioDsp,\n    FaustPolyWebAudioDsp,\n    FaustWasmInstantiator,\n    FaustAudioWorkletProcessorCommunicator\n};\n// Generate the actual AudioWorkletProcessor code\n(${getFaustAudioWorkletProcessor.toString()})(dependencies, faustData);\n`;\n                    const url = URL.createObjectURL(\n                        new Blob([processorCode], { type: 'text/javascript' })\n                    );\n                    await context.audioWorklet.addModule(url);\n                    // Keep the DSP name\n                    FaustPolyDspGenerator.gWorkletProcessors\n                        .get(context)\n                        ?.add(processorName);\n                } catch (e) {\n                    // console.error(`=> exception raised while running createPolyNode: ${e}`);\n                    // console.error(`=> check that your page is served using https.${e}`);\n                    throw e;\n                }\n            }\n            // Create the AWN\n            const node = new FaustPolyAudioWorkletNode(context, {\n                processorOptions: {\n                    name: processorName,\n                    voiceFactory,\n                    mixerModule,\n                    voices,\n                    sampleSize,\n                    effectFactory: effectFactory || undefined,\n                    ...processorOptions\n                }\n            });\n\n            return node as SP extends true\n                ? FaustPolyScriptProcessorNode\n                : FaustPolyAudioWorkletNode;\n        }\n    }\n\n    async createAudioWorkletProcessor(\n        name = this.name,\n        voiceFactory = this.voiceFactory as LooseFaustDspFactory,\n        effectFactory = this.effectFactory as LooseFaustDspFactory | null,\n        processorName = (voiceFactory?.shaKey || '') +\n            (effectFactory?.shaKey || '') || `${name}_poly`\n    ) {\n        if (!voiceFactory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n\n        const voiceMeta = JSON.parse(voiceFactory.json);\n        const effectMeta = effectFactory\n            ? JSON.parse(effectFactory.json)\n            : undefined;\n        const sampleSize = voiceMeta.compile_options.match('-double') ? 8 : 4;\n        // Dynamically create AudioWorkletProcessor if code not yet created\n        try {\n            const dependencies = {\n                FaustBaseWebAudioDsp,\n                FaustMonoWebAudioDsp: undefined,\n                FaustWasmInstantiator,\n                FaustPolyWebAudioDsp,\n                FaustWebAudioDspVoice,\n                FaustAudioWorkletProcessorCommunicator\n            };\n            // DSP name and JSON string for DSP are generated\n            const faustData = {\n                processorName,\n                dspName: name,\n                dspMeta: voiceMeta,\n                poly: true,\n                effectMeta\n            } as FaustData;\n            // Generate the actual AudioWorkletProcessor code\n            const Processor = getFaustAudioWorkletProcessor<true>(\n                dependencies,\n                faustData\n            );\n            return Processor;\n        } catch (e) {\n            // console.error(`=> exception raised while running createPolyNode: ${e}`);\n            // console.error(`=> check that your page is served using https.${e}`);\n            throw e;\n        }\n    }\n\n    async createOfflineProcessor(\n        sampleRate: number,\n        bufferSize: number,\n        voices: number,\n        voiceFactory = this.voiceFactory as LooseFaustDspFactory,\n        mixerModule = this.mixerModule,\n        effectFactory = this.effectFactory as LooseFaustDspFactory | null,\n        context?: BaseAudioContext\n    ) {\n        if (!voiceFactory)\n            throw new Error(\n                'Code is not compiled, please define the factory or call `await this.compile()` first.'\n            );\n\n        const voiceMeta = JSON.parse(voiceFactory.json);\n        const effectMeta = effectFactory\n            ? JSON.parse(effectFactory.json)\n            : undefined;\n        const instance = await FaustWasmInstantiator.createAsyncPolyDSPInstance(\n            voiceFactory,\n            mixerModule,\n            voices,\n            effectFactory || undefined\n        );\n        const sampleSize = voiceMeta.compile_options.match('-double') ? 8 : 4;\n        if (context) {\n            voiceFactory.soundfiles = await SoundfileReader.loadSoundfiles(\n                voiceMeta,\n                voiceFactory.soundfiles || {},\n                context\n            );\n            if (effectFactory)\n                effectFactory.soundfiles = await SoundfileReader.loadSoundfiles(\n                    effectMeta,\n                    effectFactory.soundfiles || {},\n                    context\n                );\n        }\n        const soundfiles = {\n            ...effectFactory?.soundfiles,\n            ...voiceFactory.soundfiles\n        };\n        const polyDsp = new FaustPolyWebAudioDsp(\n            instance,\n            sampleRate,\n            sampleSize,\n            bufferSize,\n            soundfiles\n        );\n        return new FaustPolyOfflineProcessor(polyDsp, bufferSize);\n    }\n\n    getMeta() {\n        const o = this.voiceFactory ? JSON.parse(this.voiceFactory.json) : null;\n        const e = this.effectFactory\n            ? JSON.parse(this.effectFactory.json)\n            : null;\n        const r = { ...o };\n        if (e) {\n            r.ui = [\n                {\n                    type: 'tgroup',\n                    label: 'Sequencer',\n                    items: [\n                        { type: 'vgroup', label: 'Instrument', items: o.ui },\n                        { type: 'vgroup', label: 'Effect', items: e.ui }\n                    ]\n                }\n            ];\n        } else {\n            r.ui = [\n                {\n                    type: 'tgroup',\n                    label: 'Polyphonic',\n                    items: [{ type: 'vgroup', label: 'Voices', items: o.ui }]\n                }\n            ];\n        }\n        return r as FaustDspMeta;\n    }\n\n    getJSON() {\n        return JSON.stringify(this.getMeta());\n    }\n\n    getUI() {\n        return this.getMeta().ui;\n    }\n}\n\ninterface JSONData {\n    meta: Array<{ options?: string }>;\n}\n\nexport class FaustDspGenerator implements IFaustDspGenerator {\n    \n    private static compilerPromise: Promise<FaustCompiler> | null = null;\n    \n    // Analyze the metadata of a Faust JSON file and extract the [midi:on] and [nvoices:n] options\n    private extractMidiAndNvoices(\n        jsonData: JSONData\n    ): { midi: boolean; nvoices: number } {\n        const optionsMetadata = jsonData.meta.find((meta) => meta.options);\n        if (optionsMetadata && optionsMetadata.options) {\n            const options = optionsMetadata.options;\n\n            const midiRegex = /\\[midi:(on|off)\\]/;\n            const nvoicesRegex = /\\[nvoices:(\\d+)\\]/;\n\n            const midiMatch = options.match(midiRegex);\n            const nvoicesMatch = options.match(nvoicesRegex);\n\n            const midi = midiMatch ? midiMatch[1] === 'on' : false;\n            const nvoices = nvoicesMatch ? parseInt(nvoicesMatch[1], 10) : -1;\n\n            return { midi, nvoices };\n        } else {\n            return { midi: false, nvoices: -1 };\n        }\n    }\n    \n    /**\n     * Compile DSP code, inspect metadata for [nvoices:] (and optionally [midi:on]), and build either a mono\n     * or poly WebAudio node (ScriptProcessor or AudioWorklet depending on `sp`). Compilation uses a shared,\n     * lazily-created libfaust instance to avoid repeatedly instantiating the WASM compiler.\n     */\n    async createFaustNode(\n        context: BaseAudioContext,\n        name: string,\n        code: string,\n        sp?: boolean,\n        bufferSize?: number,\n    ): Promise<IFaustMonoWebAudioNode | IFaustPolyWebAudioNode | null> {\n        const getCompiler = async () => {\n            if (!FaustDspGenerator.compilerPromise) {\n                // Resolve libfaust-wasm assets relative to current script/page location (works in browser and bundlers).\n                // Falling back to document/baseURI keeps things working when import.meta.url is unavailable (es2019 target).\n                const baseURL =\n                    (typeof document !== 'undefined'\n                        ? ('src' in (document.currentScript || {})\n                              ? (document.currentScript as HTMLScriptElement)\n                                    .src\n                              : document.baseURI)\n                        : undefined) ||\n                    (typeof window !== 'undefined'\n                        ? window.location.href\n                        : undefined);\n                if (!baseURL)\n                    throw new Error('Cannot resolve libfaust-wasm location.');\n                const jsURL = new URL(\n                    '../libfaust-wasm/libfaust-wasm.js',\n                    baseURL\n                    ).href;\n                const dataURL = jsURL.replace(/c?js$/, 'data');\n                const wasmURL = jsURL.replace(/c?js$/, 'wasm');\n                FaustDspGenerator.compilerPromise =\n                    instantiateFaustModuleFromFile(\n                        jsURL,\n                        dataURL,\n                        wasmURL\n                    ).then((module) => new FaustCompiler(new LibFaust(module)));\n            }\n            return FaustDspGenerator.compilerPromise;\n        };\n\n        const args = '-ftz 2';\n\n        try {\n            const compiler = await getCompiler();\n            // First compile as mono to inspect metadata for nvoices/midi tags; if nvoices > 0 we recompile as poly.\n            const monoGenerator = new FaustMonoDspGenerator();\n            const compiledMono = await monoGenerator.compile(\n                compiler,\n                name,\n                code,\n                args\n            );\n            if (!compiledMono) return null;\n\n            // Extract nvoices from metadata\n            const { nvoices } = this.extractMidiAndNvoices(\n                monoGenerator.getMeta() as unknown as JSONData\n            );\n\n            // If nvoices > 0, recompile as polyphonic\n            if (nvoices > 0) {\n                const polyGenerator = new FaustPolyDspGenerator();\n                const compiledPoly = await polyGenerator.compile(\n                    compiler,\n                    name,\n                    code,\n                    args\n                );\n                if (!compiledPoly) return null;\n\n                // Poly creation: combine voice/effect factories, create node with requested SP/AWN and buffer size.\n                return await polyGenerator.createNode(\n                    context,\n                    nvoices,\n                    name,\n                    undefined,\n                    undefined,\n                    undefined,\n                    sp,\n                    bufferSize\n                );\n            }\n\n            // Mono creation path when no polyphony hint is present.\n            return await monoGenerator.createNode(\n                context,\n                name,\n                undefined,\n                sp,\n                bufferSize\n            );\n        } catch (e) {\n            console.error(e);\n            return null;\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["FaustBaseWebAudioDsp", "FaustWasmInstantiator", "FaustAudioWorkletProcessorCommunicator", "FaustMonoWebAudioDsp", "FaustPolyWebAudioDsp", "FaustBaseWebAudioDsp", "FaustWasmInstantiator", "FaustMonoWebAudioDsp", "FaustAudioWorkletProcessorCommunicator", "RawSha256", "fromUtf8", "Sha256", "sha256", "item", "ctrl", "files", "sp"]
}
